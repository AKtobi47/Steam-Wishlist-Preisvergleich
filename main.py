#!/usr/bin/env python3
"""
Steam Price Tracker - Hauptanwendung
"""
import sys
import os
import subprocess
import json
import csv
from pathlib import Path
from datetime import datetime, timedelta
import logging
import time as time_module
import threading
from typing import Dict, List, Optional

# Core imports
from database_manager import DatabaseManager
from price_tracker import SteamPriceTracker, create_price_tracker
from steam_wishlist_manager import SteamWishlistManager

# Neue imports f√ºr dynamisches Men√º
try:
    from menu_config import get_menu_system, initialize_menu_system
    DYNAMIC_MENU_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è Dynamisches Men√º nicht verf√ºgbar - nutze klassisches Men√º")
    DYNAMIC_MENU_AVAILABLE = False

# Charts imports 
try:
    from steam_charts_manager import CHART_TYPES
    VALID_CHART_TYPES = list(CHART_TYPES.keys())
except ImportError:
    VALID_CHART_TYPES = ['most_played', 'top_releases', 'most_concurrent_players']
    print("‚ö†Ô∏è steam_charts_manager nicht verf√ºgbar - verwende Fallback Chart-Typen")

# Logging Konfiguration
try:
    from logging_config import get_main_logger
    logger = get_main_logger()
except ImportError:
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

# =================================================================
# ENHANCED CLEANUP & UTILITY FUNCTIONS
# =================================================================

def enhanced_cleanup():
    """Enhanced Cleanup beim Beenden"""
    try:
        # Background Scheduler cleanup
        try:
            from background_scheduler import cleanup_all_background_processes
            stopped = cleanup_all_background_processes()
            if stopped > 0:
                print(f"üßπ {stopped} Background-Prozesse gestoppt")
        except (ImportError, AttributeError):
            logger.debug("Background Scheduler cleanup nicht verf√ºgbar")
        
        # Charts Manager cleanup
        try:
            global charts_manager
            if 'charts_manager' in globals() and charts_manager:
                if hasattr(charts_manager, 'cleanup'):
                    charts_manager.cleanup()
                    print("üßπ Charts Manager bereinigt")
        except Exception:
            logger.debug("Charts Manager cleanup nicht verf√ºgbar")
        
        print("‚úÖ Cleanup abgeschlossen")
    except Exception as e:
        logger.debug(f"Cleanup-Fehler: {e}")

def safe_input(prompt, default=""):
    """Sichere Input-Funktion mit Fallback"""
    try:
        result = input(prompt).strip()
        return result if result else default
    except (EOFError, KeyboardInterrupt):
        return default
    except Exception as e:
        logger.warning(f"Input-Fehler: {e}")
        return default

def create_tracker_with_fallback():
    """
    Erstellt Tracker ohne Elasticsearch (wie gew√ºnscht)
    """
    print("üöÄ Steam Price Tracker wird initialisiert...")
    
    try:
        tracker = create_price_tracker(enable_charts=True)
        
        if not tracker:
            print("‚ùå Tracker konnte nicht erstellt werden")
            return None, None, None
        
        print("‚úÖ Tracker erfolgreich erstellt")
        
        # Charts Manager
        charts_manager = None
        if hasattr(tracker, 'charts_manager') and tracker.charts_manager:
            charts_manager = tracker.charts_manager
            print("‚úÖ Charts Manager verf√ºgbar")
        else:
            print("‚ÑπÔ∏è Charts Manager nicht verf√ºgbar")
        
        # ENTFERNT: Elasticsearch wird nicht mehr √ºber main.py verwaltet
        es_manager = None
        
        return tracker, charts_manager, es_manager
    
    except Exception as e:
        logger.error(f"Tracker-Initialisierung fehlgeschlagen: {e}")
        return None, None, None

def add_app_safe(tracker, steam_app_id, app_name=None, source="manual"):
    """Sichere App-Hinzuf√ºgung"""
    try:
        if hasattr(tracker, 'add_or_update_app'):
            return tracker.add_or_update_app(steam_app_id, app_name)
        elif hasattr(tracker, 'add_tracked_app'):
            return tracker.add_tracked_app(steam_app_id, app_name)
        else:
            return tracker.db_manager.add_tracked_app(steam_app_id, app_name)
    except Exception as e:
        logger.error(f"Fehler beim Hinzuf√ºgen der App {steam_app_id}: {e}")
        return False

def get_tracked_apps_safe(tracker):
    """Sicheres Abrufen der getrackte Apps"""
    try:
        if hasattr(tracker, 'get_tracked_apps'):
            return tracker.get_tracked_apps()
        elif hasattr(tracker, 'db_manager'):
            return tracker.db_manager.get_tracked_apps()
        else:
            return []
    except Exception as e:
        logger.error(f"Fehler beim Abrufen der Apps: {e}")
        return []

def load_stats_safe(tracker):
    """L√§dt Statistiken sicher mit robusterem Fallback"""
    try:
        # Versuch 1: Verwende die bestehende get_database_stats Methode
        if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'get_database_stats'):
            stats = tracker.db_manager.get_database_stats()
            # WICHTIG: Pr√ºfe ob alle erforderlichen Keys existieren
            if isinstance(stats, dict) and 'tracked_apps' in stats:
                return stats
            else:
                logger.warning("‚ö†Ô∏è get_database_stats gibt unvollst√§ndige Daten zur√ºck")
        
        # Versuch 2: Fallback - Manuelle Statistik-Berechnung
        logger.info("üîÑ Verwende manuellen Statistik-Fallback...")
        
        # Getrackte Apps z√§hlen
        tracked_apps_count = 0
        total_snapshots = 0
        newest_snapshot = None
        stores_tracked = ['Steam']  # Mindestens Steam
        
        if hasattr(tracker, 'db_manager'):
            try:
                with tracker.db_manager.get_connection() as conn:
                    cursor = conn.cursor()
                    
                    # Apps z√§hlen
                    cursor.execute('SELECT COUNT(*) FROM tracked_apps WHERE active = 1')
                    result = cursor.fetchone()
                    tracked_apps_count = result[0] if result else 0
                    
                    # Snapshots z√§hlen
                    cursor.execute('SELECT COUNT(*) FROM price_snapshots')
                    result = cursor.fetchone()
                    total_snapshots = result[0] if result else 0
                    
                    # Neuester Snapshot
                    cursor.execute('SELECT timestamp FROM price_snapshots ORDER BY timestamp DESC LIMIT 1')
                    result = cursor.fetchone()
                    newest_snapshot = result[0] if result else None
                    
                    # Stores ermitteln
                    cursor.execute('SELECT DISTINCT store FROM price_snapshots')
                    stores = cursor.fetchall()
                    if stores:
                        stores_tracked = [store[0] for store in stores]
                    
                    logger.info(f"üìä Manuelle Stats: {tracked_apps_count} Apps, {total_snapshots} Snapshots")
                    
            except Exception as db_error:
                logger.error(f"‚ùå Datenbankfehler beim manuellen Fallback: {db_error}")
                # Verwende get_tracked_apps_safe als letzten Fallback
                apps = get_tracked_apps_safe(tracker)
                tracked_apps_count = len(apps) if apps else 0
        
        # Versuch 3: Wenn immer noch keine DB-Verbindung, verwende sichere Defaults
        else:
            logger.warning("‚ö†Ô∏è Keine Datenbankverbindung verf√ºgbar")
            apps = get_tracked_apps_safe(tracker)
            tracked_apps_count = len(apps) if apps else 0
        
        # GARANTIERT vollst√§ndiges Dictionary zur√ºckgeben
        safe_stats = {
            'tracked_apps': tracked_apps_count,
            'total_snapshots': total_snapshots,
            'stores_tracked': stores_tracked,
            'newest_snapshot': newest_snapshot,
            'fallback_used': True
        }
        
        logger.info(f"‚úÖ Sichere Stats geladen: {safe_stats}")
        return safe_stats
        
    except Exception as e:
        logger.error(f"‚ùå Kritischer Fehler beim Laden der Statistiken: {e}")
        # ULTIMATE FALLBACK - verhindert KeyError
        return {
            'tracked_apps': 0,
            'total_snapshots': 0,
            'stores_tracked': ['Steam'],
            'newest_snapshot': None,
            'error': str(e),
            'fallback_used': True
        }


# =================================================================
# CHARTS OPERATIONS
# =================================================================

def update_charts_safe(charts_manager):
    """Sichere Charts-Aktualisierung"""
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return False
    
    try:
        if hasattr(charts_manager, 'update_all_charts'):
            return charts_manager.update_all_charts()
        elif hasattr(charts_manager, 'update_charts'):
            return charts_manager.update_charts()
        else:
            print("‚ùå Keine Charts-Update-Methode verf√ºgbar")
            return False
    except Exception as e:
        print(f"‚ùå Fehler beim Charts-Update: {e}")
        return False

def get_charts_deals_safe(charts_manager, tracker):
    """Sichere Charts-Deals"""
    try:
        if charts_manager and hasattr(charts_manager, 'get_current_deals'):
            return charts_manager.get_current_deals()
        
        # Fallback: Beste Deals aus Tracker
        if hasattr(tracker, 'get_best_deals'):
            return tracker.get_best_deals(limit=10)
        
        return []
    except Exception as e:
        logger.error(f"Fehler beim Laden der Charts-Deals: {e}")
        return []

# =================================================================
# MAIN MENU FUNCTIONS
# =================================================================

def menu_add_app_manually(tracker):
    """Option 1: App manuell hinzuf√ºgen"""
    print("\nüì± APP MANUELL HINZUF√úGEN")
    print("=" * 30)
    
    steam_app_id = safe_input("Steam App ID: ")
    if not steam_app_id:
        print("‚ùå Ung√ºltige App ID")
        return
    
    app_name = safe_input("App Name (optional): ")
    
    print("üîç F√ºge App zum Tracking hinzu...")
    success = add_app_safe(tracker, steam_app_id, app_name, "manual")
    
    if success:
        print(f"‚úÖ App {steam_app_id} erfolgreich hinzugef√ºgt!")
    else:
        print(f"‚ùå Fehler beim Hinzuf√ºgen der App {steam_app_id}")

def menu_import_wishlist(tracker):
    """Option 2: Steam Wishlist importieren"""
    print("\nüì• STEAM WISHLIST IMPORTIEREN")
    print("=" * 35)
    
    try:
        from steam_wishlist_manager import load_api_key_from_env
        api_key = load_api_key_from_env()
        
        if not api_key:
            print("‚ùå Steam API Key nicht gefunden")
            print("üí° Trage deinen API Key in die .env Datei ein")
            return
        
        wishlist_manager = SteamWishlistManager(api_key)
        
        steam_id = safe_input("Steam ID oder Benutzername: ")
        if not steam_id:
            print("‚ùå Steam ID erforderlich")
            return
        
        print("üîÑ Lade Wishlist...")
        wishlist = wishlist_manager.get_simple_wishlist(steam_id)
        
        if wishlist:
            print(f"üìã {len(wishlist)} Spiele in Wishlist gefunden")
            
            confirm = safe_input(f"Alle {len(wishlist)} Spiele zum Tracking hinzuf√ºgen? (j/n): ")
            if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                added = 0
                for item in wishlist:
                    app_id = item['steam_app_id']
                    name = item['name']
                    if add_app_safe(tracker, app_id, name, "wishlist"):
                        added += 1
                
                print(f"‚úÖ {added} Apps erfolgreich hinzugef√ºgt!")
            else:
                print("‚ùå Import abgebrochen")
        else:
            print("‚ùå Keine Wishlist gefunden oder Fehler beim Laden")
    
    except ImportError:
        print("‚ùå Wishlist Manager nicht verf√ºgbar")
    except Exception as e:
        print(f"‚ùå Fehler beim Wishlist-Import: {e}")

def menu_show_current_prices(tracker):
    """Option 3: Aktuelle Preise anzeigen"""
    print("\nüîç AKTUELLE PREISE")
    print("=" * 20)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps gefunden")
        return
    
    print(f"üìä {len(apps)} getrackte Apps:")
    print()
    
    for i, app in enumerate(apps[:20], 1):  # Limitiere auf 20 f√ºr bessere √úbersicht
        app_id = app.get('steam_app_id', 'N/A')
        name = app.get('name', 'Unbekannt')[:40]
        added_at = app.get('added_at', 'N/A')
        source = app.get('source', 'manual')
        
        print(f"{i:2d}. {name}")
        print(f"    üÜî {app_id} | üìÖ {added_at} | üìç {source}")
        print()

def menu_show_best_deals(tracker):
    """Option 4: Beste Deals anzeigen"""
    print("\nüìä BESTE DEALS")
    print("=" * 15)
    
    try:
        if hasattr(tracker, 'get_best_deals'):
            deals = tracker.get_best_deals(min_discount_percent=25, limit=15)
        else:
            print("‚ùå Deal-Funktion nicht verf√ºgbar")
            return
        
        if deals:
            print(f"üî• {len(deals)} Top-Deals gefunden:")
            for i, deal in enumerate(deals, 1):
                name = deal.get('name', 'Unbekannt')[:35]
                price = deal.get('current_price', 0)
                discount = deal.get('discount_percent', 0)
                store = deal.get('store', 'Steam')
                
                print(f"{i:2d}. {name}")
                print(f"    üí∞ ‚Ç¨{price:.2f} ‚Ä¢ {discount:>3.0f}% Rabatt ‚Ä¢ {store}")
        else:
            print("‚ùå Keine Deals gefunden")
            print("üí° F√ºhre zuerst ein Preis-Update durch")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Deals: {e}")

def menu_show_price_history(tracker):
    """Option 5: Preisverlauf anzeigen"""
    print("\nüìà PREISVERLAUF")
    print("=" * 15)
    
    app_id = safe_input("Steam App ID f√ºr Preisverlauf: ")
    if not app_id:
        print("‚ùå App ID erforderlich")
        return
    
    try:
        if hasattr(tracker, 'get_price_history'):
            history = tracker.get_price_history(app_id, days_back=30)
        else:
            print("‚ùå Preisverlauf-Funktion nicht verf√ºgbar")
            return
        
        if history:
            print(f"üìä Preisverlauf f√ºr App {app_id} (letzte 30 Tage):")
            for entry in history[-10:]:  # Zeige letzte 10 Eintr√§ge
                date = entry.get('date', 'N/A')
                price = entry.get('price', 0)
                store = entry.get('store', 'N/A')
                print(f"  üìÖ {date} ‚Ä¢ ‚Ç¨{price:.2f} ‚Ä¢ {store}")
        else:
            print("‚ùå Keine Preisverlaufsdaten gefunden")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden des Preisverlaufs: {e}")

def menu_update_prices(tracker):
    """Option 6: Preise manuell aktualisieren"""
    print("\nüîÑ PREISE AKTUALISIEREN")
    print("=" * 25)
    
    try:
        if hasattr(tracker, 'process_all_pending_apps_optimized'):
            print("üöÄ Starte BATCH-Preis-Update (optimiert)...")
            result = tracker.process_all_pending_apps_optimized(hours_threshold=0)
            
            if result.get('success'):
                print(f"‚úÖ BATCH-Update erfolgreich!")
                print(f"üìä {result['total_successful']}/{result['total_apps']} Apps aktualisiert")
                print(f"‚è±Ô∏è Dauer: {result['total_duration']:.1f}s")
                print(f"‚ö° {result['apps_per_second']:.1f} Apps/s")
            else:
                print(f"‚ùå BATCH-Update fehlgeschlagen: {result.get('error', '')}")
        else:
            print("‚ùå Preis-Update-Funktion nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Preis-Update: {e}")

def menu_toggle_scheduler(tracker):
    """Option 7: Automatisches Tracking starten/stoppen"""
    print("\nüöÄ AUTOMATISCHES TRACKING")
    print("=" * 30)
    
    try:
        if hasattr(tracker, 'get_scheduler_status'):
            status = tracker.get_scheduler_status()
            
            if status and status.get('scheduler_running'):
                print("üîÑ Scheduler l√§uft bereits")
                choice = safe_input("Scheduler stoppen? (j/n): ")
                if choice.lower() in ['j', 'ja', 'y', 'yes']:
                    if hasattr(tracker, 'stop_scheduler'):
                        tracker.stop_scheduler()
                        print("‚èπÔ∏è Scheduler gestoppt")
                    else:
                        print("‚ùå Stop-Funktion nicht verf√ºgbar")
            else:
                print("‚èπÔ∏è Scheduler ist gestoppt")
                choice = safe_input("Scheduler starten? (j/n): ")
                if choice.lower() in ['j', 'ja', 'y', 'yes']:
                    interval = safe_input("Update-Intervall in Stunden (Standard: 6): ", "6")
                    try:
                        interval_hours = int(interval)
                        if hasattr(tracker, 'start_scheduler'):
                            tracker.start_scheduler(interval_hours=interval_hours)
                            print(f"üöÄ Scheduler gestartet (alle {interval_hours}h)")
                        else:
                            print("‚ùå Start-Funktion nicht verf√ºgbar")
                    except ValueError:
                        print("‚ùå Ung√ºltiges Intervall")
        else:
            print("‚ùå Scheduler-Funktionen nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Scheduler-Management: {e}")

def menu_update_names_all_apps(tracker):
    """Option 8: Namen f√ºr ALLE Apps aktualisieren (NEU!)"""
    print("\nüìù NAMEN F√úR ALLE APPS AKTUALISIEREN")
    print("=" * 40)
    
    try:
        # Hole alle getrackte Apps
        apps = get_tracked_apps_safe(tracker)
        if not apps:
            print("‚ùå Keine Apps zum Aktualisieren")
            return
        
        app_ids = [app['steam_app_id'] for app in apps if app.get('steam_app_id')]
        
        if not app_ids:
            print("‚ùå Keine g√ºltigen App IDs gefunden")
            return
        
        print(f"üìù Aktualisiere Namen f√ºr {len(app_ids)} Apps...")
        print("üöÄ Nutze BATCH-optimierte Wishlist-Manager Funktion...")
        
        # Nutze bestehende Wishlist-Manager BATCH-Funktion
        from steam_wishlist_manager import bulk_get_app_names, load_api_key_from_env
        
        api_key = load_api_key_from_env()
        if not api_key:
            print("‚ùå Steam API Key nicht verf√ºgbar")
            return
        
        names_result = bulk_get_app_names(app_ids, api_key)
        
        # Namen in DB aktualisieren
        updated = 0
        failed = 0
        
        for app_id, name in names_result.items():
            try:
                # Update √ºber verschiedene m√∂gliche Methoden
                success = False
                
                if hasattr(tracker.db_manager, 'update_app_name'):
                    success = tracker.db_manager.update_app_name(app_id, name)
                else:
                    # Fallback: Direkte DB-Operation
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE tracked_apps SET name = ? WHERE steam_app_id = ?",
                            (name, app_id)
                        )
                        success = cursor.rowcount > 0
                
                if success:
                    updated += 1
                    print(f"‚úÖ {app_id}: {name[:50]}")
                else:
                    failed += 1
                    
            except Exception as e:
                failed += 1
                logger.warning(f"Namen-Update f√ºr App {app_id} fehlgeschlagen: {e}")
        
        print(f"\nüìä ERGEBNIS:")
        print(f"   ‚úÖ Erfolgreich: {updated}")
        print(f"   ‚ùå Fehlgeschlagen: {failed}")
        print(f"   üìä Gesamt: {len(app_ids)}")
        
    except Exception as e:
        print(f"‚ùå Namen-Update Fehler: {e}")

def menu_manage_apps(tracker):
    """Option 9: Getrackte Apps verwalten"""
    print("\nüìã GETRACKTE APPS VERWALTEN")
    print("=" * 30)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps gefunden")
        return
    
    print(f"üìä {len(apps)} Apps im Tracking:")
    for i, app in enumerate(apps[:10], 1):  # Zeige erste 10
        name = app.get('name', 'Unbekannt')[:30]
        app_id = app.get('steam_app_id', 'N/A')
        source = app.get('source', 'manual')
        print(f"{i:2d}. {name} ({app_id}) [{source}]")
    
    if len(apps) > 10:
        print(f"... und {len(apps) - 10} weitere")

def menu_remove_apps(tracker):
    """Option 10: Apps entfernen"""
    print("\nüóëÔ∏è APPS ENTFERNEN")
    print("=" * 18)
    
    app_id = safe_input("Steam App ID zum Entfernen: ")
    if not app_id:
        print("‚ùå App ID erforderlich")
        return
    
    try:
        if hasattr(tracker, 'remove_tracked_app'):
            success = tracker.remove_tracked_app(app_id)
        elif hasattr(tracker, 'db_manager'):
            success = tracker.db_manager.remove_tracked_app(app_id)
        else:
            print("‚ùå Remove-Funktion nicht verf√ºgbar")
            return
        
        if success:
            print(f"‚úÖ App {app_id} entfernt")
        else:
            print(f"‚ùå App {app_id} nicht gefunden oder Fehler")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Entfernen: {e}")

def menu_csv_export(tracker):
    """Option 11: CSV-Export erstellen"""
    print("\nüìÑ CSV-EXPORT")
    print("=" * 13)
    
    try:
        if hasattr(tracker, 'export_to_csv'):
            filename = tracker.export_to_csv()
            print(f"‚úÖ CSV-Export erstellt: {filename}")
        else:
            print("‚ùå Export-Funktion nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Export: {e}")

def menu_detailed_statistics(tracker):
    """Option 12: Detaillierte Statistiken"""
    print("\nüìä DETAILLIERTE STATISTIKEN")
    print("=" * 30)
    
    stats = load_stats_safe(tracker)
    
    print(f"üìä Apps im Tracking: {stats['tracked_apps']}")
    print(f"üì∏ Preis-Snapshots: {stats['total_snapshots']}")
    
    if stats['stores_tracked']:
        print(f"üè™ √úberwachte Stores: {', '.join(stats['stores_tracked'])}")
    
    if stats['newest_snapshot']:
        print(f"üïí Letztes Update: {stats['newest_snapshot']}")

def menu_show_charts(charts_manager, tracker):
    """Option 13: Charts anzeigen"""
    print("\nüìà STEAM CHARTS")
    print("=" * 17)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    try:
        if hasattr(charts_manager, 'get_charts_summary'):
            summary = charts_manager.get_charts_summary()
            print(f"üìä Charts verf√ºgbar: {summary}")
        else:
            print("üìä Charts-System ist aktiv")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Charts: {e}")

def menu_update_charts(charts_manager, tracker):
    """
    Einfache Weiterleitung zu menu_batch_charts_update
    Nutzt die bereits perfekt funktionierende Batch-Funktion
    """
    logger.warning("‚ö†Ô∏è menu_update_charts ist veraltet - nutze menu_batch_charts_update")
    menu_batch_charts_update(charts_manager)

def menu_charts_deals(charts_manager, tracker):
    """Option 15: Charts-Deals anzeigen"""
    print("\nüéØ CHARTS-DEALS")
    print("=" * 17)
    
    deals = get_charts_deals_safe(charts_manager, tracker)
    
    if deals:
        print(f"üéØ {len(deals)} Charts-Deals gefunden:")
        for i, deal in enumerate(deals[:15], 1):
            name = deal.get('name', 'Unbekannt')[:35]
            price = deal.get('current_price', 0)
            discount = deal.get('discount_percent', 0)
            store = deal.get('store', 'Steam')
            
            print(f"{i:2d}. {name}")
            print(f"    üí∞ ‚Ç¨{price:.2f} ‚Ä¢ {discount:>3.0f}% Rabatt ‚Ä¢ {store}")
    else:
        print("‚ùå Keine Charts-Deals verf√ºgbar")
        print("üí° F√ºhre zuerst ein Charts-Update durch")

def menu_charts_statistics(charts_manager, tracker):
    """Option 16: Charts-Statistiken"""
    print("\nüìä CHARTS-STATISTIKEN")
    print("=" * 25)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    try:
        if hasattr(charts_manager, 'get_charts_validation_status'):
            validation = charts_manager.get_charts_validation_status()
            
            print("üîç Charts-System Status:")
            for key, status in validation.items():
                icon = "‚úÖ" if status else "‚ùå"
                readable_key = key.replace('_', ' ').title()
                print(f"  {icon} {readable_key}")
        else:
            print("üìä Charts-Statistiken nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Charts-Statistiken: {e}")

def menu_charts_automation(charts_manager, tracker):
    """Charts-Automation mit BATCH-Updates - FIXED VERSION"""
    print("\nü§ñ CHARTS-AUTOMATION")
    print("=" * 25)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    print("ü§ñ Automation-Optionen:")
    print("1. üöÄ Einmaliges vollst√§ndiges Update")
    print("2. üìä Einmaliges Charts-Update (schnell)")
    print("3. ‚è∞ Scheduler-Status anzeigen")
    print("4. üîÑ Scheduler konfigurieren")
    print("5. üõë Automation stoppen")
    print("0. ‚Ü©Ô∏è Zur√ºck")
    
    choice = safe_input("Auswahl (0-5): ")
    
    if choice == "0":
        return
    
    elif choice == "1":
        # Vollst√§ndiges einmaliges Update
        print("üöÄ Starte einmaliges vollst√§ndiges Update...")
        
        if hasattr(charts_manager, 'update_all_charts_batch'):
            try:
                start_time = time_module.time()
                result = charts_manager.update_all_charts_batch(
                    include_names=True,
                    include_prices=True
                )
                duration = time_module.time() - start_time
                
                if result.get('overall_success'):
                    print(f"‚úÖ Vollst√§ndiges Update erfolgreich in {duration:.1f}s!")
                    
                    # Performance-Metriken
                    if 'performance_metrics' in result:
                        metrics = result['performance_metrics']
                        print(f"üìä Apps verarbeitet: {metrics.get('apps_processed', 'N/A')}")
                        print(f"üìù Namen aktualisiert: {metrics.get('names_updated', 'N/A')}")
                        print(f"üí∞ Preise aktualisiert: {metrics.get('prices_updated', 'N/A')}")
                else:
                    print("‚ö†Ô∏è Update mit Einschr√§nkungen abgeschlossen")
            except Exception as e:
                print(f"‚ùå Update-Fehler: {e}")
        else:
            print("‚ùå BATCH-Update nicht verf√ºgbar")
    
    elif choice == "2":
        # Schnelles Charts-Update
        print("üìä Starte schnelles Charts-Update...")
        
        if hasattr(charts_manager, 'update_all_charts_batch'):
            try:
                start_time = time_module.time()
                result = charts_manager.update_all_charts_batch(
                    include_names=False,
                    include_prices=False
                )
                duration = time_module.time() - start_time
                
                if result.get('overall_success'):
                    print(f"‚úÖ Schnelles Update erfolgreich in {duration:.1f}s!")
                else:
                    print("‚ö†Ô∏è Update fehlgeschlagen")
            except Exception as e:
                print(f"‚ùå Update-Fehler: {e}")
        else:
            print("‚ùå BATCH-Update nicht verf√ºgbar")
    
    elif choice == "3":
        # Scheduler-Status
        print("‚è∞ Scheduler-Status:")
        try:
            if hasattr(tracker, 'get_scheduler_status'):
                status = tracker.get_scheduler_status()
                print(f"üìä Status: {status.get('status', 'Unbekannt')}")
                if status.get('next_run'):
                    print(f"‚è∞ N√§chster Lauf: {status['next_run']}")
            else:
                print("‚ö†Ô∏è Scheduler-Status nicht verf√ºgbar")
        except Exception as e:
            print(f"‚ùå Fehler: {e}")
    
    elif choice == "4":
        # Scheduler konfigurieren
        print("üîÑ Scheduler-Konfiguration:")
        print("üí° Diese Funktion w√ºrde Scheduler-Einstellungen bearbeiten")
        print("üí° Integration mit background_scheduler.py")
    
    elif choice == "5":
        # Automation stoppen
        print("üõë Stoppe Charts-Automation...")
        try:
            if hasattr(tracker, 'stop_scheduler'):
                tracker.stop_scheduler()
                print("‚úÖ Automation gestoppt")
            else:
                print("‚ö†Ô∏è Stop-Funktion nicht verf√ºgbar")
        except Exception as e:
            print(f"‚ùå Fehler: {e}")

def menu_batch_charts_update(charts_manager):
    """Erweiterte BATCH-Charts-Update mit allen Optionen"""
    print("\nüöÄ ERWEITERTE BATCH-CHARTS-UPDATE")
    print("=" * 40)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    print("üéØ BATCH-Update Optionen:")
    print("1. üöÄ Vollst√§ndig mit Progress (Charts + Namen + Preise)")
    print("2. üìä Nur Charts-Daten (Ultraschnell)")
    print("3. üìù Charts + Namen (ohne Preise)")
    print("4. üí∞ Charts + Preise (ohne Namen)")
    print("5. üéØ Vollst√§ndig benutzerdefiniert")
    print("6. üìà Performance-Vergleich anzeigen")
    print("0. ‚Ü©Ô∏è Zur√ºck")
    
    choice = safe_input("Auswahl (0-6): ")
    
    if choice == "0":
        return
    
    # Parameter setzen
    include_names = True
    include_prices = True
    chart_types = None
    show_progress = True
    
    if choice == "2":
        include_names = False
        include_prices = False
        show_progress = False
    elif choice == "3":
        include_prices = False
    elif choice == "4":
        include_names = False
    elif choice == "5":
        # Vollst√§ndig benutzerdefiniert
        include_names = safe_input("Namen aktualisieren? (j/n): ").lower() in ['j', 'y']
        include_prices = safe_input("Preise aktualisieren? (j/n): ").lower() in ['j', 'y']
        show_progress = safe_input("Progress-Anzeige? (j/n): ").lower() in ['j', 'y']
        
        # Chart-Typen
        print("\nChart-Typen ausw√§hlen:")
        try:
            from steam_charts_manager import CHART_TYPES
            available_charts = list(CHART_TYPES.keys())
        except ImportError:
            available_charts = ['most_played', 'top_releases', 'most_concurrent_players']
        
        for i, chart in enumerate(available_charts, 1):
            print(f"{i}. {chart.replace('_', ' ').title()}")
        print(f"{len(available_charts) + 1}. Alle")
        
        chart_choice = safe_input(f"Chart-Auswahl (1-{len(available_charts) + 1}): ")
        if chart_choice != str(len(available_charts) + 1):
            try:
                idx = int(chart_choice) - 1
                if 0 <= idx < len(available_charts):
                    chart_types = [available_charts[idx]]
            except ValueError:
                pass
    
    elif choice == "6":
        # Performance-Vergleich
        print("\nüìà PERFORMANCE-VERGLEICH:")
        print("=" * 30)
        print("üêå Legacy update_all_charts(): ~7+ Minuten")
        print("üöÄ BATCH update_all_charts_batch(): ~30 Sekunden")
        print("‚ö° Performance-Gewinn: 15x schneller!")
        print("\nüí° BATCH-Features:")
        print("   üì¶ 99% weniger Database-Locks")
        print("   üåê BULK API-Aufrufe f√ºr Namen")
        print("   üí∞ BATCH Preis-Updates")
        print("   üìä Live-Progress-Anzeige")
        return
    
    # Update-Zusammenfassung
    print(f"\nüéØ BATCH-UPDATE KONFIGURATION:")
    print(f"üìä Chart-Typen: {len(chart_types) if chart_types else 'Alle'}")
    print(f"üìù Namen-Updates: {'‚úÖ' if include_names else '‚ùå'}")
    print(f"üí∞ Preis-Updates: {'‚úÖ' if include_prices else '‚ùå'}")
    print(f"üìà Progress-Anzeige: {'‚úÖ' if show_progress else '‚ùå'}")
    
    confirm = safe_input("\nüöÄ BATCH-Update starten? (j/n): ")
    if confirm.lower() not in ['j', 'y', 'ja', 'yes']:
        print("‚ùå Update abgebrochen")
        return
    
    # Progress-Tracker (optional)
    progress_tracker = None
    if show_progress:
        progress_tracker = ProgressTracker()
        progress_tracker.start()
    
    try:
        print("\nüöÄ BATCH-Update gestartet...")
        
        start_time = time_module.time()
        
        # Progress-Callback
        def progress_callback(progress_info):
            if progress_tracker:
                progress_tracker.update_progress(progress_info)
        
        # üöÄ BATCH UPDATE
        if hasattr(charts_manager, 'update_all_charts_batch'):
            result = charts_manager.update_all_charts_batch(
                chart_types=chart_types,
                include_names=include_names,
                include_prices=include_prices,
                progress_callback=progress_callback if show_progress else None
            )
            
            duration = time_module.time() - start_time
            
            if result.get('overall_success'):
                print(f"\nüéâ BATCH-Update erfolgreich in {duration:.1f}s!")
                
                # Detaillierte Ergebnisse
                if 'performance_metrics' in result:
                    metrics = result['performance_metrics']
                    print(f"\nüìä PERFORMANCE-METRIKEN:")
                    print(f"   üìä Charts verarbeitet: {metrics.get('charts_processed', 'N/A')}")
                    print(f"   üéÆ Apps verarbeitet: {metrics.get('apps_processed', 'N/A')}")
                    if include_names:
                        print(f"   üìù Namen aktualisiert: {metrics.get('names_updated', 'N/A')}")
                    if include_prices:
                        print(f"   üí∞ Preise aktualisiert: {metrics.get('prices_updated', 'N/A')}")
                    print(f"   üöÄ Performance: {metrics.get('performance_boost', '15x faster')}")
                
            else:
                print(f"\n‚ö†Ô∏è BATCH-Update mit Einschr√§nkungen in {duration:.1f}s")
                if 'error' in result:
                    print(f"‚ùå Fehler: {result['error']}")
        
        else:
            print("‚ùå BATCH-Update nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå BATCH-Update Fehler: {e}")
        # F√ºr Debugging:
        import traceback
        traceback.print_exc()
    
    finally:
        if progress_tracker:
            progress_tracker.stop()

# Elasticsearch-Funktionen 
def menu_elasticsearch_export(es_manager, tracker):
    """Option 18: ES Daten exportieren"""
    print("\nüì§ ELASTICSEARCH EXPORT")
    print("=" * 25)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    print("üì§ Exportiere Daten zu Elasticsearch...")
    print("üí° Diese Funktion ist noch in Entwicklung")

def menu_elasticsearch_dashboard(es_manager):
    """Option 19: Kibana Dashboard"""
    print("\nüìä KIBANA DASHBOARD")
    print("=" * 20)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    print("üìä √ñffne Kibana Dashboard...")
    print("üí° Dashboard unter http://localhost:5601")

def menu_elasticsearch_analytics(es_manager):
    """Option 20: ES Analytics"""
    print("\nüî¨ ELASTICSEARCH ANALYTICS")
    print("=" * 28)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    print("üî¨ Elasticsearch Analytics werden geladen...")
    print("üí° Diese Funktion ist noch in Entwicklung")

def menu_elasticsearch_config(es_manager):
    """Option 21: ES Konfiguration"""
    print("\n‚öôÔ∏è ELASTICSEARCH KONFIGURATION")
    print("=" * 32)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    print("‚öôÔ∏è Elasticsearch Konfiguration...")
    print("üí° Diese Funktion ist noch in Entwicklung")

def menu_elasticsearch_sync(es_manager, tracker):
    """Option 22: ES Synchronisierung"""
    print("\nüîÑ ELASTICSEARCH SYNC")
    print("=" * 22)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    print("üîÑ Synchronisiere Daten mit Elasticsearch...")
    print("üí° Diese Funktion ist noch in Entwicklung")

# System-Tools 
def menu_system_tools(tracker):
    """Option 23: System-Tools"""
    print("\nüîß SYSTEM-TOOLS")
    print("=" * 17)
    
    stats = load_stats_safe(tracker)
    
    print("üîß System-Information:")
    print(f"  üìä Apps: {stats['tracked_apps']}")
    print(f"  üì∏ Snapshots: {stats['total_snapshots']}")
    print(f"  üïí Python: {sys.version.split()[0]}")
    print(f"  üíæ Platform: {sys.platform}")

def menu_process_management():
    """Option 24: Process Management"""
    print("\nüîß PROCESS MANAGEMENT")
    print("=" * 23)
    
    try:
        from background_scheduler import main as scheduler_main
        print("üöÄ Starte Process Management Terminal...")
        scheduler_main()
    except ImportError:
        print("‚ùå Background Scheduler nicht verf√ºgbar")
    except Exception as e:
        print(f"‚ùå Fehler beim Process Management: {e}")

def menu_batch_processing(tracker):
    """Option 25: Batch Processing"""
    print("\nüì¶ BATCH PROCESSING")
    print("=" * 20)
    
    print("üì¶ Batch Processing Optionen:")
    print("1. Batch-Update f√ºr ausstehende Apps")
    print("2. Spezifische Apps aktualisieren")
    print("3. Batch-Status anzeigen")
    
    choice = safe_input("Auswahl (1-3): ")
    
    if choice == "1":
        try:
            if hasattr(tracker, 'process_all_pending_apps_optimized'):
                print("üöÄ Starte Batch-Update...")
                result = tracker.process_all_pending_apps_optimized(hours_threshold=6)
                print(f"‚úÖ Batch-Update abgeschlossen: {result}")
            else:
                print("‚ùå Batch-Update Funktion nicht verf√ºgbar")
        except Exception as e:
            print(f"‚ùå Batch-Update Fehler: {e}")
    elif choice == "2":
        app_ids = safe_input("App IDs (kommagetrennt): ")
        if app_ids:
            app_list = [aid.strip() for aid in app_ids.split(',')]
            print(f"üéØ Aktualisiere {len(app_list)} spezifische Apps...")
            # Implementierung f√ºr spezifische Apps
    elif choice == "3":
        print("üìä Batch-Status wird angezeigt...")
    else:
        print("‚ùå Ung√ºltige Auswahl")

def menu_database_maintenance(tracker):
    """Option 26: Datenbank-Wartung"""
    print("\nüßπ DATENBANK-WARTUNG")
    print("=" * 22)
    
    print("üßπ Wartungsoptionen:")
    print("1. Alte Preisdaten bereinigen")
    print("2. Datenbank optimieren")
    print("3. Statistiken anzeigen")
    
    choice = safe_input("Auswahl (1-3): ")
    
    if choice == "1":
        days = safe_input("Daten √§lter als X Tage l√∂schen (Standard: 90): ", "90")
        try:
            days_int = int(days)
            if hasattr(tracker.db_manager, 'cleanup_old_prices'):
                deleted = tracker.db_manager.cleanup_old_prices(days_int)
                print(f"üßπ {deleted} alte Preisdaten gel√∂scht")
            else:
                print("‚ùå Cleanup-Funktion nicht verf√ºgbar")
        except ValueError:
            print("‚ùå Ung√ºltige Tagesanzahl")
    elif choice == "2":
        try:
            if hasattr(tracker.db_manager, 'vacuum_database'):
                tracker.db_manager.vacuum_database()
                print("‚úÖ Datenbank optimiert")
            else:
                print("‚ùå Vacuum-Funktion nicht verf√ºgbar")
        except Exception as e:
            print(f"‚ùå Optimierung fehlgeschlagen: {e}")
    elif choice == "3":
        stats = load_stats_safe(tracker)
        print(f"üìä Datenbank-Statistiken: {stats}")
    else:
        print("‚ùå Ung√ºltige Auswahl")

def menu_create_backup(tracker):
    """Option 27: Backup erstellen"""
    print("\nüíæ BACKUP ERSTELLEN")
    print("=" * 19)
    
    try:
        if hasattr(tracker.db_manager, 'backup_database'):
            backup_file = tracker.db_manager.backup_database()
            print(f"üíæ Backup erstellt: {backup_file}")
        else:
            print("‚ùå Backup-Funktion nicht verf√ºgbar")
    except Exception as e:
        print(f"‚ùå Backup-Fehler: {e}")

def menu_edit_configuration():
    """Option 28: Konfiguration bearbeiten"""
    print("\n‚öôÔ∏è KONFIGURATION BEARBEITEN")
    print("=" * 30)
    
    print("‚öôÔ∏è Konfigurationsoptionen:")
    print("1. .env Datei bearbeiten")
    print("2. config.json anzeigen")
    print("3. API Keys verwalten")
    
    choice = safe_input("Auswahl (1-3): ")
    
    if choice == "1":
        print("üìù .env Datei bearbeiten...")
        print("üí° √ñffne .env in deinem bevorzugten Editor")
    elif choice == "2":
        print("üìÑ config.json wird angezeigt...")
        if os.path.exists("config.json"):
            try:
                with open("config.json", 'r') as f:
                    config = json.load(f)
                print(json.dumps(config, indent=2))
            except Exception as e:
                print(f"‚ùå Fehler beim Laden der config.json: {e}")
        else:
            print("‚ùå config.json nicht gefunden")
    elif choice == "3":
        print("üîë API Keys verwalten...")
        print("üí° Diese Funktion ist noch in Entwicklung")
    else:
        print("‚ùå Ung√ºltige Auswahl")

# =================================================================
# DYNAMIC MENU SYSTEM INTEGRATION
# =================================================================

def run_dynamic_menu():
    """
    F√ºhrt das dynamische Men√ºsystem aus - VOLLST√ÑNDIGE VERSION
    Alle Funktionen unified auf update_all_charts_batch()
    """
    try:
        # Initialisierung
        print("üöÄ Steam Price Tracker wird initialisiert...")
        tracker, charts_manager, es_manager = create_tracker_with_fallback()
        
        if not tracker:
            print("‚ùå Kritischer Fehler: Price Tracker konnte nicht initialisiert werden")
            return False
        
        # Dynamisches Men√º initialisieren
        try:
            menu_system = initialize_menu_system(
                charts_enabled=bool(charts_manager),
                es_available=bool(es_manager)
            )
        except Exception as menu_error:
            logger.error(f"‚ùå Fehler beim Initialisieren des Men√ºsystems: {menu_error}")
            print(f"‚ùå Men√ºsystem-Fehler: {menu_error}")
            return False
        
        # Startup-Info
        try:
            stats = load_stats_safe(tracker)
            print("\n" + "=" * 60)
            print("üéÆ STEAM PRICE TRACKER - DYNAMISCHES MEN√ú")
            print("=" * 60)
            print(f"üìä Getrackte Apps: {stats.get('tracked_apps', 0)}")
            print(f"üì∏ Preis-Snapshots: {stats.get('total_snapshots', 0)}")
            
            if charts_manager:
                print("üìà Charts: Aktiviert (BATCH-optimiert)")
            if es_manager:
                print("üîç Elasticsearch: Verf√ºgbar")
            
            print("=" * 60)
            
        except Exception as stats_error:
            logger.error(f"‚ùå Fehler beim Laden der Startup-Statistiken: {stats_error}")
            print("\n" + "=" * 60)
            print("üéÆ STEAM PRICE TRACKER - DYNAMISCHES MEN√ú")
            print("=" * 60)
            print("‚ö†Ô∏è Statistiken konnten nicht geladen werden")
            print("=" * 60)
        
        # VOLLST√ÑNDIGE FUNCTION MAP - ALLE FUNKTIONEN
        function_map = {
            # üè† BASIS-FUNKTIONEN
            'menu_add_app_manually': lambda: menu_add_app_manually(tracker),
            'menu_import_wishlist': lambda: menu_import_wishlist(tracker),
            'menu_show_current_prices': lambda: menu_show_current_prices(tracker),
            'menu_show_best_deals': lambda: menu_show_best_deals(tracker),
            'menu_show_price_history': lambda: menu_show_price_history(tracker),
            'menu_update_prices': lambda: menu_update_prices(tracker),
            
            # üöÄ AUTOMATION & BATCH
            'menu_toggle_scheduler': lambda: menu_toggle_scheduler(tracker),
            'menu_update_names_all_apps': lambda: menu_update_names_all_apps(tracker),
            
            # üéÆ APP-VERWALTUNG
            'menu_manage_apps': lambda: menu_manage_apps(tracker),
            'menu_remove_apps': lambda: menu_remove_apps(tracker),
            'menu_csv_export': lambda: menu_csv_export(tracker),
            'menu_detailed_statistics': lambda: menu_detailed_statistics(tracker),
            
            # üìä CHARTS & ANALYTICS (alle unified auf update_all_charts_batch)
            'menu_show_charts': lambda: menu_show_charts(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_update_charts_complete': lambda: menu_batch_charts_update(charts_manager) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_charts_deals': lambda: menu_charts_deals(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_charts_statistics': lambda: menu_charts_statistics(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_charts_automation': lambda: menu_charts_automation(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            # üöÄ NEUE ERWEITERTE BATCH-FUNKTION
            'menu_batch_charts_update': lambda: menu_batch_charts_update(charts_manager) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            
            # üîç ELASTICSEARCH
            'menu_elasticsearch_export': lambda: menu_elasticsearch_export(es_manager, tracker) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_dashboard': lambda: menu_elasticsearch_dashboard(es_manager) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_analytics': lambda: menu_elasticsearch_analytics(es_manager) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_config': lambda: menu_elasticsearch_config(es_manager) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_sync': lambda: menu_elasticsearch_sync(es_manager, tracker) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            
            # üõ†Ô∏è SYSTEM-TOOLS
            'menu_system_settings': lambda: menu_system_settings(),
            'menu_system_info': lambda: menu_system_info(tracker, charts_manager, es_manager),
            'menu_backup_export': lambda: menu_backup_export(tracker),
            'menu_backup_import': lambda: menu_backup_import(tracker),
            'menu_health_check': lambda: menu_health_check(tracker, charts_manager),
            'menu_clean_database': lambda: menu_clean_database(tracker),
            'menu_dev_tools': lambda: menu_dev_tools(tracker)
        }
        
        # Hauptschleife
        while True:
            try:
                menu_system.display_menu()
                max_option = menu_system.get_max_option_number()
                choice = input(f"\nW√§hlen Sie eine Option (0-{max_option}): ").strip()
                
                if choice == "0":
                    print("\nüëã Auf Wiedersehen!")
                    break
                
                # Option ausf√ºhren
                if choice in menu_system.option_mapping:
                    category_idx, option_name, handler = menu_system.option_mapping[choice]
                    
                    print(f"\n‚û§ {option_name}")
                    
                    if handler in function_map:
                        try:
                            function_map[handler]()
                        except Exception as func_error:
                            logger.error(f"‚ùå Fehler in Funktion {handler}: {func_error}")
                            print(f"‚ùå Fehler beim Ausf√ºhren von {option_name}: {func_error}")
                    else:
                        print(f"‚ùå Funktion '{handler}' nicht implementiert")
                        logger.warning(f"Handler '{handler}' nicht in function_map gefunden")
                else:
                    print(f"‚ùå Ung√ºltige Auswahl: {choice}")
                    print(f"Bitte w√§hlen Sie eine Option zwischen 0-{max_option}.")
                
                # Pause zwischen Operationen
                if choice != "0":
                    input("\nDr√ºcke Enter zum Fortfahren...")
            
            except KeyboardInterrupt:
                print("\n\n‚èπÔ∏è Programm durch Benutzer unterbrochen")
                print("üßπ Enhanced Cleanup wird ausgef√ºhrt...")
                enhanced_cleanup()
                break
            except Exception as e:
                logger.error(f"Unerwarteter Fehler in der Hauptschleife: {e}")
                print(f"‚ùå Unerwarteter Fehler: {e}")
                print("üí° Das Programm l√§uft weiter...")
                input("Dr√ºcke Enter zum Fortfahren...")
        
        return True
    
    except Exception as e:
        logger.error(f"Kritischer Fehler im dynamischen Men√º: {e}")
        print(f"‚ùå Kritischer Fehler: {e}")
        return False


def execute_menu_handler(handler_name: str, tracker, charts_manager, es_manager):
    """F√ºhrt Menu-Handler aus"""
    try:
        # Handler-Mapping f√ºr dynamisches Men√º
        handlers = {
            # Basis-Funktionen
            'menu_add_app_manually': lambda: menu_add_app_manually(tracker),
            'menu_import_wishlist': lambda: menu_import_wishlist(tracker),
            'menu_show_current_prices': lambda: menu_show_current_prices(tracker),
            'menu_show_best_deals': lambda: menu_show_best_deals(tracker),
            'menu_show_price_history': lambda: menu_show_price_history(tracker),
            'menu_update_prices': lambda: menu_update_prices(tracker),
            
            # Automation
            'menu_toggle_scheduler': lambda: menu_toggle_scheduler(tracker),
            'menu_update_names_all_apps': lambda: menu_update_names_all_apps(tracker),
            
            # Management
            'menu_manage_apps': lambda: menu_manage_apps(tracker),
            'menu_remove_apps': lambda: menu_remove_apps(tracker),
            'menu_csv_export': lambda: menu_csv_export(tracker),
            'menu_detailed_statistics': lambda: menu_detailed_statistics(tracker),
            
            # Charts (nur wenn verf√ºgbar)
            'menu_show_charts': lambda: menu_show_charts(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_update_charts_complete': lambda: menu_update_charts(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_charts_deals': lambda: menu_charts_deals(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_charts_statistics': lambda: menu_charts_statistics(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            'menu_charts_automation': lambda: menu_charts_automation(charts_manager, tracker) if charts_manager else print("‚ùå Charts Manager nicht verf√ºgbar"),
            
            # Elasticsearch (nur wenn verf√ºgbar)
            'menu_elasticsearch_export': lambda: menu_elasticsearch_export(es_manager, tracker) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_dashboard': lambda: menu_elasticsearch_dashboard(es_manager) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_analytics': lambda: menu_elasticsearch_analytics(es_manager) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_config': lambda: menu_elasticsearch_config(es_manager) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            'menu_elasticsearch_sync': lambda: menu_elasticsearch_sync(es_manager, tracker) if es_manager else print("‚ùå Elasticsearch Manager nicht verf√ºgbar"),
            
            # System-Tools
            'menu_system_tools': lambda: menu_system_tools(tracker),
            'menu_process_management': lambda: menu_process_management(),
            'menu_batch_processing': lambda: menu_batch_processing(tracker),
            'menu_database_maintenance': lambda: menu_database_maintenance(tracker),
            'menu_create_backup': lambda: menu_create_backup(tracker),
            'menu_edit_configuration': lambda: menu_edit_configuration(),
        }
        
        if handler_name in handlers:
            handlers[handler_name]()
        else:
            print(f"‚ùå Handler '{handler_name}' nicht implementiert")
            
    except Exception as e:
        logger.error(f"Handler-Fehler f√ºr {handler_name}: {e}")
        print(f"‚ùå Fehler beim Ausf√ºhren von {handler_name}: {e}")

# =================================================================
# CLASSIC MENU SYSTEM (bestehend, als Fallback)
# =================================================================

def run_classic_menu():
    """
    Klassisches Men√º mit allen Optionen - VOLLST√ÑNDIGE VERSION
    Alle Charts-Funktionen unified auf update_all_charts_batch()
    """
    try:
        # Initialisierung
        print("üöÄ Steam Price Tracker wird initialisiert...")
        tracker, charts_manager, es_manager = create_tracker_with_fallback()
        
        if not tracker:
            print("‚ùå Kritischer Fehler: Price Tracker konnte nicht initialisiert werden")
            return False
        
        charts_enabled = bool(charts_manager)
        es_enabled = bool(es_manager)
        
        # Startup-Info
        try:
            stats = load_stats_safe(tracker)
            print("\n" + "=" * 60)
            print("üéÆ STEAM PRICE TRACKER - KLASSISCHES MEN√ú")
            print("=" * 60)
            print(f"üìä Getrackte Apps: {stats.get('tracked_apps', 0)}")
            print(f"üì∏ Preis-Snapshots: {stats.get('total_snapshots', 0)}")
            
            if charts_enabled:
                print("üìà Charts: Aktiviert (BATCH-optimiert)")
            if es_enabled:
                print("üîç Elasticsearch: Verf√ºgbar")
            
            print("=" * 60)
        except Exception as e:
            logger.error(f"‚ùå Startup-Statistiken Fehler: {e}")
        
        # Hauptschleife
        while True:
            try:
                # VOLLST√ÑNDIGES KLASSISCHES MEN√ú
                print("\nüéÆ HAUPTMEN√ú")
                print("=" * 60)
                
                # üè† BASIS-FUNKTIONEN (1-6)
                print("üè† BASIS-FUNKTIONEN")
                print("1.  üì± App manuell hinzuf√ºgen")
                print("2.  üì• Steam Wishlist importieren") 
                print("3.  üîç Aktuelle Preise anzeigen")
                print("4.  üìä Beste Deals anzeigen")
                print("5.  üìà Preisverlauf anzeigen")
                print("6.  üîÑ Preise manuell aktualisieren")
                
                # üöÄ AUTOMATION & BATCH (7-8)
                print("\nüöÄ AUTOMATION & BATCH")
                print("7.  üöÄ Automatisches Tracking")
                print("8.  üìù Namen f√ºr alle Apps aktualisieren")
                
                # üéÆ APP-VERWALTUNG (9-12)
                print("\nüéÆ APP-VERWALTUNG")
                print("9.  üìã Getrackte Apps verwalten")
                print("10. üóëÔ∏è Apps entfernen")
                print("11. üìÑ CSV-Export erstellen")
                print("12. üìä Detaillierte Statistiken")
                
                # üìä CHARTS & ANALYTICS (13-18) - VOLLST√ÑNDIG MIT BATCH
                if charts_enabled:
                    print("\nüìä CHARTS & ANALYTICS (BATCH-optimiert)")
                    print("13. üìà Charts anzeigen")
                    print("14. üöÄ Charts vollst√§ndig aktualisieren (BATCH)")
                    print("15. üéØ Charts-Deals anzeigen")
                    print("16. üìä Charts-Statistiken")
                    print("17. ü§ñ Charts-Automation")
                    print("18. üì¶ Erweiterte BATCH-Optionen")  # üöÄ NEUE OPTION
                
                # üîç ELASTICSEARCH (19-23)
                if es_enabled:
                    print("\nüîç ELASTICSEARCH")
                    print("19. üì§ ES Daten exportieren")
                    print("20. üìä Kibana Dashboard")
                    print("21. üî¨ ES Analytics")
                    print("22. ‚öôÔ∏è ES Konfiguration")
                    print("23. üîÑ ES Synchronisierung")
                
                # üõ†Ô∏è SYSTEM-TOOLS (24-30)
                print("\nüõ†Ô∏è SYSTEM-TOOLS")
                print("24. ‚öôÔ∏è System-Einstellungen")
                print("25. üìä System-Informationen")
                print("26. üíæ Backup erstellen")
                print("27. üì• Backup importieren")
                print("28. üîç Health Check")
                print("29. üßπ Datenbank bereinigen")
                print("30. üîß Developer Tools")
                
                print("\n0.  üëã Beenden")
                print("=" * 60)
                
                # Eingabe
                choice = safe_input("W√§hlen Sie eine Option (0-30): ")
                
                # VOLLST√ÑNDIGE MENU-HANDLER
                if choice == "0":
                    print("\nüëã Auf Wiedersehen!")
                    print("üßπ Enhanced Cleanup wird ausgef√ºhrt...")
                    enhanced_cleanup()
                    break
                
                # üè† BASIS-FUNKTIONEN (1-6)
                elif choice == "1":
                    menu_add_app_manually(tracker)
                elif choice == "2":
                    menu_import_wishlist(tracker)
                elif choice == "3":
                    menu_show_current_prices(tracker)
                elif choice == "4":
                    menu_show_best_deals(tracker)
                elif choice == "5":
                    menu_show_price_history(tracker)
                elif choice == "6":
                    menu_update_prices(tracker)
                
                # üöÄ AUTOMATION & BATCH (7-8)
                elif choice == "7":
                    menu_toggle_scheduler(tracker)
                elif choice == "8":
                    menu_update_names_all_apps(tracker)
                
                # üéÆ APP-VERWALTUNG (9-12)
                elif choice == "9":
                    menu_manage_apps(tracker)
                elif choice == "10":
                    menu_remove_apps(tracker)
                elif choice == "11":
                    menu_csv_export(tracker)
                elif choice == "12":
                    menu_detailed_statistics(tracker)
                
                # üìä CHARTS & ANALYTICS (13-18) - UNIFIED BATCH CALLS
                elif choice == "13":
                    if charts_enabled:
                        menu_show_charts(charts_manager, tracker)
                    else:
                        print("‚ùå Charts Manager nicht verf√ºgbar")
                elif choice == "14":
                    if charts_enabled:
                        menu_update_charts(charts_manager, tracker)  # üöÄ NUTZT update_all_charts_batch()
                    else:
                        print("‚ùå Charts Manager nicht verf√ºgbar")
                elif choice == "15":
                    if charts_enabled:
                        menu_charts_deals(charts_manager, tracker)
                    else:
                        print("‚ùå Charts Manager nicht verf√ºgbar")
                elif choice == "16":
                    if charts_enabled:
                        menu_charts_statistics(charts_manager, tracker)
                    else:
                        print("‚ùå Charts Manager nicht verf√ºgbar")
                elif choice == "17":
                    if charts_enabled:
                        menu_charts_automation(charts_manager, tracker)
                    else:
                        print("‚ùå Charts Manager nicht verf√ºgbar")
                elif choice == "18":
                    if charts_enabled:
                        menu_batch_charts_update(charts_manager)  # üöÄ NEUE ERWEITERTE BATCH-OPTIONEN
                    else:
                        print("‚ùå Charts Manager nicht verf√ºgbar")
                
                # üîç ELASTICSEARCH (19-23)
                elif choice == "19":
                    if es_enabled:
                        menu_elasticsearch_export(es_manager, tracker)
                    else:
                        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
                elif choice == "20":
                    if es_enabled:
                        menu_elasticsearch_dashboard(es_manager)
                    else:
                        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
                elif choice == "21":
                    if es_enabled:
                        menu_elasticsearch_analytics(es_manager)
                    else:
                        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
                elif choice == "22":
                    if es_enabled:
                        menu_elasticsearch_config(es_manager)
                    else:
                        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
                elif choice == "23":
                    if es_enabled:
                        menu_elasticsearch_sync(es_manager, tracker)
                    else:
                        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
                
                # üõ†Ô∏è SYSTEM-TOOLS (24-30)
                elif choice == "24":
                    menu_system_settings()
                elif choice == "25":
                    menu_system_info(tracker, charts_manager, es_manager)
                elif choice == "26":
                    menu_backup_export(tracker)
                elif choice == "27":
                    menu_backup_import(tracker)
                elif choice == "28":
                    menu_health_check(tracker, charts_manager)
                elif choice == "29":
                    menu_clean_database(tracker)
                elif choice == "30":
                    menu_dev_tools(tracker)
                
                else:
                    print(f"‚ùå Ung√ºltige Auswahl: {choice}")
                    print("Bitte w√§hlen Sie eine Option zwischen 0-30.")
                
                # Pause zwischen Operationen
                if choice != "0":
                    input("\nDr√ºcke Enter zum Fortfahren...")
            
            except KeyboardInterrupt:
                print("\n\n‚èπÔ∏è Programm durch Benutzer unterbrochen")
                print("üßπ Enhanced Cleanup wird ausgef√ºhrt...")
                enhanced_cleanup()
                break
            except Exception as e:
                logger.error(f"Unerwarteter Fehler in der Hauptschleife: {e}")
                print(f"‚ùå Unerwarteter Fehler: {e}")
                print("üí° Das Programm l√§uft weiter...")
                input("Dr√ºcke Enter zum Fortfahren...")
        
        return True
    
    except Exception as e:
        logger.error(f"Kritischer Fehler im klassischen Men√º: {e}")
        print(f"‚ùå Kritischer Fehler: {e}")
        return False

class ProgressTracker:
    """
    üéØ PROGRESS-ANZEIGE mit Throbber und Prozentanzeige - FIXED VERSION
    """
    
    def __init__(self):
        self.is_running = False
        self.current_progress = {}
        self.throbber_chars = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
        self.throbber_index = 0
        self.phase_icons = {
            'charts': 'üìä',
            'names': 'üìù', 
            'prices': 'üí∞',
            'complete': '‚úÖ'
        }
        self.phase_names = {
            'charts': 'Charts-Daten sammeln',
            'names': 'Namen aktualisieren',
            'prices': 'Preise aktualisieren',
            'complete': 'Abgeschlossen'
        }
    
    def start(self):
        """Startet die Progress-Anzeige"""
        self.is_running = True
        self.throbber_thread = threading.Thread(target=self._update_display, daemon=True)
        self.throbber_thread.start()
    
    def stop(self):
        """Stoppt die Progress-Anzeige"""
        self.is_running = False
        if hasattr(self, 'throbber_thread'):
            self.throbber_thread.join(timeout=1)
        self._clear_line()
    
    def update_progress(self, progress_info):
        """Update des Fortschritts"""
        self.current_progress = progress_info
    
    def _update_display(self):
        """Aktualisiert die Anzeige kontinuierlich - FIXED VERSION"""
        while self.is_running:
            self._draw_progress()
            # GEFIXT: VERWENDE time_module ANSTATT time
            time_module.sleep(0.1)  # ‚Üê HIER WAR AUCH EIN PROBLEM!
            self.throbber_index = (self.throbber_index + 1) % len(self.throbber_chars)
    
    def _draw_progress(self):
        """Zeichnet die aktuelle Progress-Anzeige"""
        if not self.current_progress:
            throbber = self.throbber_chars[self.throbber_index]
            sys.stdout.write(f"\r{throbber} Steam Price Tracker l√§uft...")
            sys.stdout.flush()
            return
        
        phase = self.current_progress.get('phase', 'unknown')
        current = self.current_progress.get('current', 0)
        total = self.current_progress.get('total', 1)
        percentage = self.current_progress.get('percentage', 0)
        details = self.current_progress.get('details', '')
        elapsed = self.current_progress.get('elapsed_time', 0)
        
        # Icons und Namen
        icon = self.phase_icons.get(phase, 'üîÑ')
        phase_name = self.phase_names.get(phase, phase.title())
        
        # Throbber (nur wenn nicht komplett)
        throbber = '' if phase == 'complete' else self.throbber_chars[self.throbber_index] + ' '
        
        # Fortschrittsbalken
        progress_bar = ''
        if total > 1 and current <= total:
            bar_length = 20
            filled_length = int(bar_length * percentage / 100)
            bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
            progress_bar = f"[{bar}] {percentage:.1f}% ({current}/{total})"
        
        # Zeit-Anzeige
        time_display = f"{elapsed:.1f}s"
        if percentage > 5 and percentage < 95:
            eta = (elapsed / percentage * 100) - elapsed if percentage > 0 else 0
            time_display += f" (ETA: {eta:.1f}s)"
        
        # Vollst√§ndige Zeile
        line = f"\r{throbber}{icon} {phase_name}"
        if progress_bar:
            line += f" {progress_bar}"
        line += f" ‚è±Ô∏è {time_display}"
        if details:
            max_details_length = 50
            if len(details) > max_details_length:
                details = details[:max_details_length - 3] + "..."
            line += f" | {details}"
        
        # Zeile ausgeben
        line = line.ljust(120)
        sys.stdout.write(line)
        sys.stdout.flush()
    
    def _clear_line(self):
        """L√∂scht die aktuelle Zeile"""
        sys.stdout.write('\r' + ' ' * 120 + '\r')
        sys.stdout.flush()


# =================================================================
# MAIN ENTRY POINT
# =================================================================

def main():
    """Haupteinstiegspunkt mit Menu-System Auswahl"""
    try:
        # Kommandozeilen-Argumente pr√ºfen
        if len(sys.argv) > 1:
            if "--dynamic" in sys.argv:
                if DYNAMIC_MENU_AVAILABLE:
                    print("üöÄ Starte dynamisches Men√º-System...")
                    return run_dynamic_menu()
                else:
                    print("‚ùå Dynamisches Men√º nicht verf√ºgbar")
                    print("üí° Installiere menu_config.py und starte erneut")
                    return False
            elif "--classic" in sys.argv:
                print("üìä Starte klassisches Men√º-System...")
                return run_classic_menu()
        
        # Standard: Pr√ºfe ob dynamisches Men√º verf√ºgbar ist
        if DYNAMIC_MENU_AVAILABLE:
            print("üöÄ Starte dynamisches Men√º-System...")
            print("üí° Nutze --classic f√ºr das alte Men√º")
            return run_dynamic_menu()
        else:
            print("üìä Starte klassisches Men√º-System...")
            print("üí° Installiere menu_config.py f√ºr das dynamische Men√º")
            return run_classic_menu()
    
    except Exception as e:
        logger.error(f"Kritischer Fehler in main(): {e}")
        print(f"‚ùå Kritischer Fehler: {e}")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)