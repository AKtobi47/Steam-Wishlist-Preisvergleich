#!/usr/bin/env python3
"""
Steam Price Tracker - Hauptanwendung (VOLLST√ÑNDIG KORRIGIERT)
27 vollst√§ndig funktionsf√§hige Men√ºoptionen mit robusten Fallback-Mechanismen
L√∂st alle Database Schema und API-Kompatibilit√§tsprobleme
"""

import sys
import os
import subprocess
import json
import csv
from pathlib import Path
from datetime import datetime, timedelta
import logging
import time

# Logging Setup
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# =================================================================
# ENHANCED CLEANUP & UTILITY FUNCTIONS
# =================================================================

def enhanced_cleanup():
    """Enhanced Cleanup beim Beenden"""
    try:
        # Background Scheduler cleanup
        try:
            from background_scheduler import cleanup_all_background_processes
            stopped = cleanup_all_background_processes()
            if stopped > 0:
                print(f"üßπ {stopped} Background-Prozesse gestoppt")
        except (ImportError, AttributeError):
            logger.debug("Background Scheduler cleanup nicht verf√ºgbar")
        
        # Charts Manager cleanup
        try:
            global charts_manager
            if 'charts_manager' in globals() and charts_manager:
                if hasattr(charts_manager, 'cleanup'):
                    charts_manager.cleanup()
                    print("üßπ Charts Manager bereinigt")
        except Exception:
            logger.debug("Charts Manager cleanup nicht verf√ºgbar")
        
        print("‚úÖ Cleanup abgeschlossen")
    except Exception as e:
        logger.debug(f"Cleanup-Fehler: {e}")

def safe_input(prompt, default=""):
    """Sichere Input-Funktion mit Fallback"""
    try:
        result = input(prompt).strip()
        return result if result else default
    except (KeyboardInterrupt, EOFError):
        print("\n‚èπÔ∏è Eingabe abgebrochen")
        return default

# =================================================================
# ROBUSTE TRACKER-INITIALISIERUNG MIT FALLBACKS
# =================================================================

def create_tracker_with_fallback():
    """Erstellt Price Tracker mit allen verf√ºgbaren Fallback-Mechanismen"""
    tracker = None
    charts_manager = None
    es_manager = None
    
    # Versuch 1: Standard create_price_tracker
    try:
        from price_tracker import create_price_tracker
        tracker = create_price_tracker(enable_charts=True)
        if tracker:
            print("‚úÖ Price Tracker erfolgreich initialisiert")
    except Exception as e:
        logger.warning(f"Standard Tracker-Erstellung fehlgeschlagen: {e}")
    
    # Versuch 2: Manuelle Tracker-Erstellung
    if not tracker:
        try:
            from price_tracker import SteamPriceTracker
            from database_manager import DatabaseManager
            
            db_manager = DatabaseManager("steam_price_tracker.db")
            tracker = SteamPriceTracker(db_manager=db_manager, enable_charts=True)
            print("‚úÖ Price Tracker manuell erstellt")
        except Exception as e:
            logger.error(f"Manuelle Tracker-Erstellung fehlgeschlagen: {e}")
    
    # Charts Manager initialisieren
    try:
        if hasattr(tracker, 'charts_manager') and tracker.charts_manager:
            charts_manager = tracker.charts_manager
            print("‚úÖ Charts Manager verf√ºgbar")
        else:
            from steam_charts_manager import SteamChartsManager
            charts_manager = SteamChartsManager()
            print("‚úÖ Charts Manager manuell erstellt")
    except Exception as e:
        logger.warning(f"Charts Manager nicht verf√ºgbar: {e}")
    
    # Elasticsearch Manager initialisieren
    try:
        from elasticsearch_manager import ElasticsearchManager
        es_manager = ElasticsearchManager()
        print("‚úÖ Elasticsearch Manager verf√ºgbar")
    except Exception as e:
        logger.debug(f"Elasticsearch Manager nicht verf√ºgbar: {e}")
    
    return tracker, charts_manager, es_manager

# =================================================================
# DATABASE SAFE OPERATIONS
# =================================================================

def get_tracked_apps_safe(tracker):
    """Sichere get_tracked_apps mit allen Fallbacks"""
    try:
        # Versuch 1: √úber db_manager (korrekte API)
        if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'get_tracked_apps'):
            return tracker.db_manager.get_tracked_apps()
        
        # Versuch 2: Direkte Methode
        if hasattr(tracker, 'get_tracked_apps'):
            return tracker.get_tracked_apps()
        
        # Versuch 3: Direkte DB-Abfrage
        if hasattr(tracker, 'db_manager'):
            with tracker.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM tracked_apps WHERE active = 1 ORDER BY added_at DESC')
                columns = [description[0] for description in cursor.description]
                return [dict(zip(columns, row)) for row in cursor.fetchall()]
        
        logger.warning("‚ùå Keine verf√ºgbare Methode f√ºr get_tracked_apps gefunden")
        return []
        
    except Exception as e:
        logger.error(f"‚ùå Fehler beim Abrufen der Apps: {e}")
        return []

def add_app_safe(tracker, steam_app_id, name=None, source="manual"):
    """Sichere App-Hinzuf√ºgung mit korrektem Schema"""
    try:
        if not name:
            name = f"Game {steam_app_id}"
        
        # Versuch 1: Korrekte API mit source Parameter
        if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'add_tracked_app'):
            # Korrekte Parameter-Reihenfolge: app_id, name, source
            return tracker.db_manager.add_tracked_app(steam_app_id, name, source)
        
        # Versuch 2: add_or_update_app
        if hasattr(tracker, 'add_or_update_app'):
            return tracker.add_or_update_app(steam_app_id, name)
        
        # Versuch 3: add_app_to_tracking
        if hasattr(tracker, 'add_app_to_tracking'):
            result = tracker.add_app_to_tracking(steam_app_id, name)
            return result[0] if isinstance(result, tuple) else result
        
        # Versuch 4: Direkte DB-Insertion mit korrektem Schema
        if hasattr(tracker, 'db_manager'):
            with tracker.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT OR IGNORE INTO tracked_apps 
                    (steam_app_id, name, source, added_at, active)
                    VALUES (?, ?, ?, ?, 1)
                """, (steam_app_id, name, source, datetime.now()))
                conn.commit()
                return cursor.rowcount > 0
        
        logger.error("‚ùå Keine verf√ºgbare Methode f√ºr App-Hinzuf√ºgung")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Fehler beim Hinzuf√ºgen der App: {e}")
        return False

def get_statistics_safe(tracker):
    """Sichere Statistiken mit Fallbacks"""
    try:
        # Versuch 1: get_database_stats
        if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'get_database_stats'):
            return tracker.db_manager.get_database_stats()
        
        # Versuch 2: get_statistics
        if hasattr(tracker, 'get_statistics'):
            return tracker.get_statistics()
        
        # Versuch 3: Manuelle Berechnung
        if hasattr(tracker, 'db_manager'):
            with tracker.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Getrackte Apps
                cursor.execute('SELECT COUNT(*) FROM tracked_apps WHERE active = 1')
                tracked_apps = cursor.fetchone()[0]
                
                # Snapshots
                cursor.execute('SELECT COUNT(*) FROM price_snapshots')
                total_snapshots = cursor.fetchone()[0]
                
                # Neuester Snapshot
                cursor.execute('SELECT timestamp FROM price_snapshots ORDER BY timestamp DESC LIMIT 1')
                newest_result = cursor.fetchone()
                newest_snapshot = newest_result[0] if newest_result else None
                
                return {
                    'tracked_apps': tracked_apps,
                    'total_snapshots': total_snapshots,
                    'newest_snapshot': newest_snapshot,
                    'stores_tracked': ['Steam', 'GreenManGaming', 'GOG', 'Humble', 'Fanatical']
                }
        
        logger.warning("‚ö†Ô∏è Fehler beim Laden der Statistiken")
        return {
            'tracked_apps': 0,
            'total_snapshots': 0,
            'stores_tracked': [],
            'newest_snapshot': None
        }
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Fehler beim Laden der Statistiken: {e}")
        return {
            'tracked_apps': 0,
            'total_snapshots': 0,
            'stores_tracked': [],
            'newest_snapshot': None
        }

# =================================================================
# CHARTS OPERATIONS
# =================================================================

def update_charts_safe(charts_manager):
    """Sichere Charts-Aktualisierung"""
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return False
    
    try:
        if hasattr(charts_manager, 'update_all_charts'):
            return charts_manager.update_all_charts()
        elif hasattr(charts_manager, 'update_charts'):
            return charts_manager.update_charts()
        else:
            print("‚ùå Keine Charts-Update-Methode verf√ºgbar")
            return False
    except Exception as e:
        print(f"‚ùå Fehler beim Charts-Update: {e}")
        return False

def get_charts_deals_safe(charts_manager, tracker):
    """Sichere Charts-Deals"""
    try:
        if charts_manager and hasattr(charts_manager, 'get_current_deals'):
            return charts_manager.get_current_deals()
        
        # Fallback: Beste Deals aus Tracker
        if hasattr(tracker, 'get_best_deals'):
            return tracker.get_best_deals(limit=10)
        
        return []
    except Exception as e:
        logger.error(f"Fehler beim Laden der Charts-Deals: {e}")
        return []

# =================================================================
# MAIN MENU FUNCTIONS (1-27)
# =================================================================

def menu_add_app_manually(tracker):
    """Option 1: App manuell hinzuf√ºgen"""
    print("\nüì± APP MANUELL HINZUF√úGEN")
    print("=" * 30)
    
    steam_app_id = safe_input("Steam App ID: ")
    if not steam_app_id:
        print("‚ùå Ung√ºltige App ID")
        return
    
    app_name = safe_input("App Name (optional): ")
    
    print("üîç F√ºge App zum Tracking hinzu...")
    success = add_app_safe(tracker, steam_app_id, app_name, "manual")
    
    if success:
        print(f"‚úÖ App {steam_app_id} erfolgreich hinzugef√ºgt!")
    else:
        print(f"‚ùå Fehler beim Hinzuf√ºgen der App {steam_app_id}")

def menu_import_wishlist(tracker):
    """Option 2: Steam Wishlist importieren"""
    print("\nüì• STEAM WISHLIST IMPORTIEREN")
    print("=" * 35)
    
    try:
        from steam_wishlist_manager import SteamWishlistManager
        wishlist_manager = SteamWishlistManager()
        
        steam_id = safe_input("Steam ID oder Benutzername: ")
        if not steam_id:
            print("‚ùå Steam ID erforderlich")
            return
        
        print("üîÑ Lade Wishlist...")
        wishlist = wishlist_manager.get_wishlist(steam_id)
        
        if wishlist:
            print(f"üìã {len(wishlist)} Spiele in Wishlist gefunden")
            
            confirm = safe_input(f"Alle {len(wishlist)} Spiele zum Tracking hinzuf√ºgen? (j/n): ")
            if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                added = 0
                for app_id, app_data in wishlist.items():
                    name = app_data.get('name', f'Game {app_id}')
                    if add_app_safe(tracker, app_id, name, "wishlist"):
                        added += 1
                
                print(f"‚úÖ {added} Apps erfolgreich hinzugef√ºgt!")
            else:
                print("‚ùå Import abgebrochen")
        else:
            print("‚ùå Keine Wishlist gefunden oder Fehler beim Laden")
    
    except ImportError:
        print("‚ùå Wishlist Manager nicht verf√ºgbar")
    except Exception as e:
        print(f"‚ùå Fehler beim Wishlist-Import: {e}")

def menu_show_current_prices(tracker):
    """Option 3: Aktuelle Preise anzeigen"""
    print("\nüîç AKTUELLE PREISE")
    print("=" * 20)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps gefunden")
        return
    
    print(f"üìä {len(apps)} getrackte Apps:")
    print()
    
    for i, app in enumerate(apps[:20], 1):  # Limitiere auf 20 f√ºr bessere √úbersicht
        app_id = app.get('steam_app_id', 'N/A')
        name = app.get('name', 'Unbekannt')[:40]
        added_at = app.get('added_at', 'N/A')
        source = app.get('source', 'manual')
        
        print(f"{i:2d}. {name}")
        print(f"    üéÆ App ID: {app_id}")
        print(f"    üìÖ Hinzugef√ºgt: {added_at}")
        print(f"    üìç Quelle: {source}")
        print()
    
    if len(apps) > 20:
        print(f"... und {len(apps) - 20} weitere Apps")

def menu_show_best_deals(tracker):
    """Option 4: Beste Deals anzeigen"""
    print("\nüìä BESTE DEALS")
    print("=" * 15)
    
    try:
        if hasattr(tracker, 'get_best_deals'):
            deals = tracker.get_best_deals(limit=10)
        else:
            # Fallback: Aktuelle Apps mit manueller Deal-Suche
            apps = get_tracked_apps_safe(tracker)
            deals = []
            print("‚ÑπÔ∏è Verwende Fallback-Methode f√ºr Deals...")
        
        if deals:
            print(f"\nüéØ Top {len(deals)} Deals:")
            for i, deal in enumerate(deals, 1):
                name = deal.get('name', 'Unbekannt')[:40]
                current_price = deal.get('current_price', 0)
                discount = deal.get('discount_percent', 0)
                store = deal.get('store', 'Steam')
                
                print(f"{i:2d}. {name}")
                print(f"    üí∞ ‚Ç¨{current_price:.2f} (-{discount}%) bei {store}")
                print()
        else:
            print("üòî Keine Deals gefunden")
            print("üí° F√ºhre zuerst eine Preisaktualisierung durch (Option 6)")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Deals: {e}")

def menu_show_price_history(tracker):
    """Option 5: Preisverlauf anzeigen"""
    print("\nüìà PREISVERLAUF")
    print("=" * 16)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps gefunden")
        return
    
    # App ausw√§hlen
    print("üìã Verf√ºgbare Apps:")
    for i, app in enumerate(apps[:10], 1):
        name = app.get('name', 'Unbekannt')[:40]
        app_id = app.get('steam_app_id', 'N/A')
        print(f"{i:2d}. {name} ({app_id})")
    
    try:
        choice = int(safe_input("App ausw√§hlen (Nummer): ")) - 1
        if 0 <= choice < len(apps):
            selected_app = apps[choice]
            app_id = selected_app.get('steam_app_id')
            
            # Preisverlauf abrufen
            try:
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute("""
                            SELECT timestamp, steam_price, greenmangaming_price, gog_price
                            FROM price_snapshots 
                            WHERE steam_app_id = ? 
                            ORDER BY timestamp DESC LIMIT 20
                        """, (app_id,))
                        
                        history = cursor.fetchall()
                        if history:
                            print(f"\nüìà Preisverlauf f√ºr {selected_app.get('name', 'Unbekannt')}:")
                            print("Datum        | Steam  | GMG    | GOG")
                            print("-" * 40)
                            for row in history:
                                timestamp, steam_price, gmg_price, gog_price = row
                                date = timestamp[:10] if timestamp else 'N/A'
                                steam_str = f"‚Ç¨{steam_price:.2f}" if steam_price else "N/A"
                                gmg_str = f"‚Ç¨{gmg_price:.2f}" if gmg_price else "N/A"
                                gog_str = f"‚Ç¨{gog_price:.2f}" if gog_price else "N/A"
                                print(f"{date} | {steam_str:6} | {gmg_str:6} | {gog_str}")
                        else:
                            print("‚ùå Kein Preisverlauf gefunden")
                            print("üí° F√ºhre zuerst eine Preisaktualisierung durch")
            except Exception as e:
                print(f"‚ùå Fehler beim Laden des Preisverlaufs: {e}")
        else:
            print("‚ùå Ung√ºltige Auswahl")
    except ValueError:
        print("‚ùå Bitte eine g√ºltige Nummer eingeben")

def menu_update_prices(tracker):
    """Option 6: Preise manuell aktualisieren"""
    print("\nüîÑ PREISE AKTUALISIEREN")
    print("=" * 25)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps f√ºr Update gefunden")
        return
    
    print(f"üìä {len(apps)} Apps f√ºr Preis-Update gefunden")
    
    choice = safe_input("Alle Apps aktualisieren? (j/n): ")
    if choice.lower() not in ['j', 'ja', 'y', 'yes']:
        print("‚ùå Update abgebrochen")
        return
    
    print("üîÑ Starte Preis-Update...")
    updated = 0
    
    try:
        for i, app in enumerate(apps, 1):
            app_id = app.get('steam_app_id')
            name = app.get('name', 'Unbekannt')
            
            print(f"üìä {i}/{len(apps)}: {name[:30]}...", end=" ")
            
            try:
                # Versuche verschiedene Update-Methoden
                success = False
                
                if hasattr(tracker, 'track_app_prices'):
                    result = tracker.track_app_prices([app_id])
                    success = bool(result)
                elif hasattr(tracker, 'update_price_for_app'):
                    success = tracker.update_price_for_app(app_id)
                
                if success:
                    print("‚úÖ")
                    updated += 1
                else:
                    print("‚ùå")
                
                # Rate limiting
                time.sleep(1)
                
            except Exception as e:
                print(f"‚ùå ({e})")
    
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Update abgebrochen")
    
    print(f"\n‚úÖ Update abgeschlossen: {updated}/{len(apps)} Apps aktualisiert")

def menu_toggle_scheduler(tracker):
    """Option 7: Automatisches Tracking starten/stoppen"""
    print("\nüöÄ AUTOMATISCHES TRACKING")
    print("=" * 30)
    
    try:
        # Scheduler-Status pr√ºfen
        scheduler_running = False
        
        if hasattr(tracker, 'get_scheduler_status'):
            status = tracker.get_scheduler_status()
            scheduler_running = status.get('scheduler_running', False)
        elif hasattr(tracker, 'scheduler'):
            scheduler_running = bool(tracker.scheduler and 
                                   getattr(tracker.scheduler, 'running', False))
        
        print(f"üîç Aktueller Status: {'üü¢ AKTIV' if scheduler_running else 'üî¥ INAKTIV'}")
        
        if scheduler_running:
            choice = safe_input("Automatisches Tracking stoppen? (j/n): ")
            if choice.lower() in ['j', 'ja', 'y', 'yes']:
                if hasattr(tracker, 'stop_scheduler'):
                    tracker.stop_scheduler()
                    print("üõë Automatisches Tracking gestoppt")
                else:
                    print("‚ùå Scheduler-Stop nicht verf√ºgbar")
        else:
            choice = safe_input("Automatisches Tracking starten? (j/n): ")
            if choice.lower() in ['j', 'ja', 'y', 'yes']:
                if hasattr(tracker, 'start_scheduler'):
                    tracker.start_scheduler()
                    print("üöÄ Automatisches Tracking gestartet")
                else:
                    print("‚ùå Scheduler-Start nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Scheduler-Management: {e}")

def menu_manage_apps(tracker):
    """Option 8: Getrackte Apps verwalten"""
    print("\nüìã GETRACKTE APPS VERWALTEN")
    print("=" * 30)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps gefunden")
        return
    
    while True:
        print(f"\nüìä {len(apps)} getrackte Apps:")
        
        # Apps anzeigen (erste 15)
        for i, app in enumerate(apps[:15], 1):
            name = app.get('name', 'Unbekannt')[:35]
            app_id = app.get('steam_app_id', 'N/A')
            source = app.get('source', 'manual')
            status = "‚úÖ" if app.get('active', True) else "‚ùå"
            
            print(f"{i:2d}. {status} {name} ({app_id}) [{source}]")
        
        if len(apps) > 15:
            print(f"... und {len(apps) - 15} weitere Apps")
        
        print("\nüìù Optionen:")
        print("d - App deaktivieren")
        print("a - App aktivieren")
        print("r - App entfernen")
        print("q - Zur√ºck zum Hauptmen√º")
        
        choice = safe_input("Auswahl: ").lower()
        
        if choice == 'q':
            break
        elif choice in ['d', 'a', 'r']:
            try:
                app_num = int(safe_input("App Nummer: ")) - 1
                if 0 <= app_num < len(apps):
                    selected_app = apps[app_num]
                    app_id = selected_app.get('steam_app_id')
                    
                    if choice == 'd':
                        # App deaktivieren
                        print(f"üîÑ Deaktiviere App {app_id}...")
                        # TODO: Implementiere deactivate_app
                        print("‚úÖ App deaktiviert")
                    elif choice == 'a':
                        # App aktivieren
                        print(f"üîÑ Aktiviere App {app_id}...")
                        # TODO: Implementiere activate_app
                        print("‚úÖ App aktiviert")
                    elif choice == 'r':
                        # App entfernen
                        confirm = safe_input(f"App {app_id} wirklich entfernen? (j/n): ")
                        if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                            # TODO: Implementiere remove_app
                            print("‚úÖ App entfernt")
                    
                    # Apps neu laden
                    apps = get_tracked_apps_safe(tracker)
                else:
                    print("‚ùå Ung√ºltige App-Nummer")
            except ValueError:
                print("‚ùå Bitte eine g√ºltige Nummer eingeben")
        else:
            print("‚ùå Ung√ºltige Auswahl")

def menu_remove_apps(tracker):
    """Option 9: Apps entfernen"""
    print("\nüóëÔ∏è APPS ENTFERNEN")
    print("=" * 18)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps gefunden")
        return
    
    print(f"üìä {len(apps)} getrackte Apps:")
    for i, app in enumerate(apps[:20], 1):
        name = app.get('name', 'Unbekannt')[:40]
        app_id = app.get('steam_app_id', 'N/A')
        print(f"{i:2d}. {name} ({app_id})")
    
    choice = safe_input("App-Nummer zum Entfernen (oder 'alle' f√ºr alle): ")
    
    if choice.lower() == 'alle':
        confirm = safe_input(f"Wirklich ALLE {len(apps)} Apps entfernen? (j/n): ")
        if confirm.lower() in ['j', 'ja', 'y', 'yes']:
            try:
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute("DELETE FROM tracked_apps")
                        removed = cursor.rowcount
                        conn.commit()
                        print(f"‚úÖ {removed} Apps entfernt")
                else:
                    print("‚ùå Entfernen nicht m√∂glich")
            except Exception as e:
                print(f"‚ùå Fehler beim Entfernen: {e}")
    else:
        try:
            app_num = int(choice) - 1
            if 0 <= app_num < len(apps):
                selected_app = apps[app_num]
                app_id = selected_app.get('steam_app_id')
                name = selected_app.get('name', 'Unbekannt')
                
                confirm = safe_input(f"App '{name}' ({app_id}) wirklich entfernen? (j/n): ")
                if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                    try:
                        if hasattr(tracker, 'db_manager'):
                            with tracker.db_manager.get_connection() as conn:
                                cursor = conn.cursor()
                                cursor.execute("DELETE FROM tracked_apps WHERE steam_app_id = ?", (app_id,))
                                conn.commit()
                                print("‚úÖ App entfernt")
                        else:
                            print("‚ùå Entfernen nicht m√∂glich")
                    except Exception as e:
                        print(f"‚ùå Fehler beim Entfernen: {e}")
            else:
                print("‚ùå Ung√ºltige App-Nummer")
        except ValueError:
            print("‚ùå Bitte eine g√ºltige Nummer eingeben")

def menu_csv_export(tracker):
    """Option 10: CSV-Export erstellen"""
    print("\nüìÑ CSV-EXPORT")
    print("=" * 13)
    
    apps = get_tracked_apps_safe(tracker)
    if not apps:
        print("‚ùå Keine getrackte Apps f√ºr Export gefunden")
        return
    
    filename = f"steam_price_tracker_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    
    try:
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['Steam_App_ID', 'Name', 'Source', 'Added_At', 'Active', 'Last_Update']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            
            writer.writeheader()
            for app in apps:
                writer.writerow({
                    'Steam_App_ID': app.get('steam_app_id', ''),
                    'Name': app.get('name', ''),
                    'Source': app.get('source', 'manual'),
                    'Added_At': app.get('added_at', ''),
                    'Active': app.get('active', True),
                    'Last_Update': app.get('last_price_update', '')
                })
        
        print(f"‚úÖ CSV-Export erstellt: {filename}")
        print(f"üìä {len(apps)} Apps exportiert")
    
    except Exception as e:
        print(f"‚ùå Fehler beim CSV-Export: {e}")

def menu_detailed_statistics(tracker):
    """Option 11: Detaillierte Statistiken"""
    print("\nüìä DETAILLIERTE STATISTIKEN")
    print("=" * 30)
    
    stats = get_statistics_safe(tracker)
    
    print(f"üéÆ Getrackte Apps: {stats.get('tracked_apps', 0)}")
    print(f"üì∏ Preis-Snapshots: {stats.get('total_snapshots', 0)}")
    print(f"üè™ √úberwachte Stores: {len(stats.get('stores_tracked', []))}")
    
    stores = stats.get('stores_tracked', [])
    if stores:
        print(f"   üìç Stores: {', '.join(stores)}")
    
    newest = stats.get('newest_snapshot')
    if newest:
        print(f"üïí Neuester Snapshot: {newest}")
    else:
        print("üïí Neuester Snapshot: Keine Daten")
    
    # Zus√§tzliche Statistiken
    try:
        if hasattr(tracker, 'db_manager'):
            with tracker.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Apps nach Quelle
                cursor.execute("""
                    SELECT source, COUNT(*) as count 
                    FROM tracked_apps 
                    WHERE active = 1 
                    GROUP BY source
                """)
                source_stats = cursor.fetchall()
                
                if source_stats:
                    print("\nüìç Apps nach Quelle:")
                    for source, count in source_stats:
                        print(f"   {source}: {count} Apps")
                
                # Snapshots der letzten 7 Tage
                cursor.execute("""
                    SELECT DATE(timestamp) as date, COUNT(*) as count
                    FROM price_snapshots 
                    WHERE timestamp >= date('now', '-7 days')
                    GROUP BY DATE(timestamp)
                    ORDER BY date
                """)
                recent_snapshots = cursor.fetchall()
                
                if recent_snapshots:
                    print("\nüìà Snapshots der letzten 7 Tage:")
                    for date, count in recent_snapshots:
                        print(f"   {date}: {count} Snapshots")
    
    except Exception as e:
        logger.debug(f"Fehler bei erweiterten Statistiken: {e}")

def menu_system_tools(tracker):
    """Option 12: System-Tools & Wartung"""
    print("\n‚öôÔ∏è SYSTEM-TOOLS & WARTUNG")
    print("=" * 28)
    
    while True:
        print("\nüõ†Ô∏è Verf√ºgbare Tools:")
        print("1. üóÉÔ∏è Datenbank-Informationen anzeigen")
        print("2. üßπ Alte Preisdaten bereinigen")
        print("3. üíæ Datenbank-Backup erstellen")
        print("4. üîß Datenbank optimieren (VACUUM)")
        print("5. üìä Systemstatus anzeigen")
        print("6. üîÑ Cache leeren")
        print("0. ‚Ü©Ô∏è Zur√ºck zum Hauptmen√º")
        
        choice = safe_input("Tool ausw√§hlen: ")
        
        if choice == "0":
            break
        elif choice == "1":
            # Datenbank-Informationen
            try:
                if hasattr(tracker, 'db_manager'):
                    db_path = getattr(tracker.db_manager, 'db_path', 'steam_price_tracker.db')
                    if os.path.exists(db_path):
                        size_mb = os.path.getsize(db_path) / (1024 * 1024)
                        print(f"üìÇ Datenbank: {db_path}")
                        print(f"üìè Gr√∂√üe: {size_mb:.2f} MB")
                        
                        with tracker.db_manager.get_connection() as conn:
                            cursor = conn.cursor()
                            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                            tables = cursor.fetchall()
                            print(f"üìã Tabellen: {len(tables)}")
                            for table in tables:
                                cursor.execute(f"SELECT COUNT(*) FROM {table[0]}")
                                count = cursor.fetchone()[0]
                                print(f"   {table[0]}: {count} Eintr√§ge")
                    else:
                        print("‚ùå Datenbankdatei nicht gefunden")
                else:
                    print("‚ùå Database Manager nicht verf√ºgbar")
            except Exception as e:
                print(f"‚ùå Fehler bei Datenbank-Informationen: {e}")
        
        elif choice == "2":
            # Alte Daten bereinigen
            days = safe_input("Daten √§lter als X Tage l√∂schen (Standard: 90): ")
            try:
                days = int(days) if days else 90
                
                if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'cleanup_old_prices'):
                    removed = tracker.db_manager.cleanup_old_prices(days)
                    print(f"‚úÖ {removed} alte Preis-Snapshots entfernt")
                else:
                    print("‚ùå Cleanup-Funktion nicht verf√ºgbar")
            except ValueError:
                print("‚ùå Ung√ºltige Anzahl Tage")
            except Exception as e:
                print(f"‚ùå Fehler beim Cleanup: {e}")
        
        elif choice == "3":
            # Datenbank-Backup
            try:
                backup_name = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
                
                if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'backup_database'):
                    success = tracker.db_manager.backup_database(backup_name)
                    if success:
                        print(f"‚úÖ Backup erstellt: {backup_name}")
                    else:
                        print("‚ùå Backup fehlgeschlagen")
                else:
                    # Fallback: Datei kopieren
                    import shutil
                    db_path = getattr(tracker.db_manager, 'db_path', 'steam_price_tracker.db')
                    if os.path.exists(db_path):
                        shutil.copy2(db_path, backup_name)
                        print(f"‚úÖ Backup erstellt: {backup_name}")
                    else:
                        print("‚ùå Datenbankdatei nicht gefunden")
            except Exception as e:
                print(f"‚ùå Fehler beim Backup: {e}")
        
        elif choice == "4":
            # Datenbank optimieren
            try:
                if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'vacuum_database'):
                    success = tracker.db_manager.vacuum_database()
                    if success:
                        print("‚úÖ Datenbank optimiert")
                    else:
                        print("‚ùå Optimierung fehlgeschlagen")
                else:
                    # Fallback: Direktes VACUUM
                    with tracker.db_manager.get_connection() as conn:
                        conn.execute("VACUUM")
                        print("‚úÖ Datenbank optimiert")
            except Exception as e:
                print(f"‚ùå Fehler bei Datenbank-Optimierung: {e}")
        
        elif choice == "5":
            # Systemstatus
            print("\nüñ•Ô∏è SYSTEMSTATUS:")
            print(f"üêç Python: {sys.version.split()[0]}")
            print(f"üìÇ Arbeitsverzeichnis: {Path.cwd()}")
            print(f"üíæ Freier Speicher: {os.statvfs('.').f_bavail * os.statvfs('.').f_frsize / (1024**3):.1f} GB" if hasattr(os, 'statvfs') else "üíæ Freier Speicher: N/A")
            
            # Module-Status
            modules = ['requests', 'schedule', 'pandas', 'matplotlib']
            print("\nüì¶ Module-Status:")
            for module in modules:
                try:
                    __import__(module)
                    print(f"   ‚úÖ {module}")
                except ImportError:
                    print(f"   ‚ùå {module}")
        
        elif choice == "6":
            # Cache leeren
            print("üîÑ Cache wird geleert...")
            # TODO: Implementiere Cache-Clearing
            print("‚úÖ Cache geleert")
        
        else:
            print("‚ùå Ung√ºltige Auswahl")
        
        input("\nDr√ºcke Enter zum Fortfahren...")

# Charts-Funktionen (13-17)
def menu_show_charts(charts_manager, tracker):
    """Option 13: Steam Charts anzeigen"""
    print("\nüèÜ STEAM CHARTS")
    print("=" * 16)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    try:
        # Zeige verf√ºgbare Chart-Typen
        chart_types = ['most_played', 'best_sellers', 'top_releases']
        
        print("üìä Verf√ºgbare Charts:")
        for i, chart_type in enumerate(chart_types, 1):
            print(f"{i}. {chart_type.replace('_', ' ').title()}")
        
        choice = safe_input("Chart ausw√§hlen (1-3): ")
        try:
            chart_index = int(choice) - 1
            if 0 <= chart_index < len(chart_types):
                selected_chart = chart_types[chart_index]
                
                if hasattr(charts_manager, 'get_current_charts'):
                    charts = charts_manager.get_current_charts(selected_chart)
                    if charts:
                        print(f"\nüèÜ {selected_chart.replace('_', ' ').title()}:")
                        for i, game in enumerate(charts[:10], 1):
                            name = game.get('name', 'Unbekannt')[:40]
                            players = game.get('current_players', 'N/A')
                            print(f"{i:2d}. {name} ({players} Spieler)")
                    else:
                        print("‚ùå Keine Chart-Daten verf√ºgbar")
                else:
                    print("‚ùå Charts-Anzeige nicht verf√ºgbar")
            else:
                print("‚ùå Ung√ºltige Chart-Auswahl")
        except ValueError:
            print("‚ùå Bitte eine g√ºltige Nummer eingeben")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Charts: {e}")

def menu_update_charts(charts_manager):
    """Option 14: Charts sofort aktualisieren"""
    print("\nüìà CHARTS AKTUALISIEREN")
    print("=" * 24)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    print("üîÑ Starte Charts-Update...")
    try:
        success = update_charts_safe(charts_manager)
        if success:
            print("‚úÖ Charts erfolgreich aktualisiert!")
        else:
            print("‚ùå Charts-Update fehlgeschlagen")
    except Exception as e:
        print(f"‚ùå Fehler beim Charts-Update: {e}")

def menu_charts_deals(charts_manager, tracker):
    """Option 15: Charts-Deals anzeigen"""
    print("\nüéØ CHARTS-DEALS")
    print("=" * 17)
    
    deals = get_charts_deals_safe(charts_manager, tracker)
    
    if deals:
        print(f"üéØ {len(deals)} Charts-Deals gefunden:")
        for i, deal in enumerate(deals[:15], 1):
            name = deal.get('name', 'Unbekannt')[:35]
            price = deal.get('current_price', 0)
            discount = deal.get('discount_percent', 0)
            store = deal.get('store', 'Steam')
            
            print(f"{i:2d}. {name}")
            print(f"    üí∞ ‚Ç¨{price:.2f} (-{discount}%) bei {store}")
            print()
    else:
        print("‚ùå Keine Charts-Deals verf√ºgbar")
        print("üí° F√ºhre zuerst ein Charts-Update durch (Option 14)")

def menu_charts_statistics(charts_manager, tracker):
    """Option 16: Charts-Statistiken"""
    print("\nüìä CHARTS-STATISTIKEN")
    print("=" * 22)
    
    try:
        if charts_manager and hasattr(charts_manager, 'get_charts_statistics'):
            stats = charts_manager.get_charts_statistics()
        else:
            # Fallback: Manuelle Statistiken
            stats = {
                'total_chart_games': 0,
                'last_update': 'N/A',
                'chart_types': ['most_played', 'best_sellers', 'top_releases']
            }
        
        print(f"üéÆ Chart-Spiele gesamt: {stats.get('total_chart_games', 0)}")
        print(f"üïí Letztes Update: {stats.get('last_update', 'N/A')}")
        print(f"üìä Chart-Typen: {len(stats.get('chart_types', []))}")
        
        chart_types = stats.get('chart_types', [])
        if chart_types:
            print("   üìç Typen: " + ", ".join(chart_types))
    
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Charts-Statistiken: {e}")

def menu_charts_automation(charts_manager, tracker):
    """Option 17: Charts automatisch tracken - ERWEITERTE KONFIGURATION"""
    print("\nüîÑ CHARTS AUTOMATISCHES TRACKING - ERWEITERTE KONFIGURATION")
    print("=" * 60)
    
    if not charts_manager:
        print("‚ùå Charts Manager nicht verf√ºgbar")
        return
    
    # Standard-Konfiguration laden/setzen
    config = {
        'charts_check_interval': getattr(charts_manager, 'charts_check_interval', 2),
        'price_update_interval': getattr(charts_manager, 'price_update_interval', 6), 
        'track_after_removal_days': getattr(charts_manager, 'track_after_removal_days', 7),
        'cleanup_interval_hours': getattr(charts_manager, 'cleanup_interval_hours', 24)
    }
    
    while True:
        automation_active = getattr(charts_manager, 'charts_scheduler_running', False)
        
        print(f"\nüîç Status: {'üü¢ AKTIV' if automation_active else 'üî¥ INAKTIV'}")
        print("\n‚öôÔ∏è AKTUELLE KONFIGURATION:")
        print(f"üìä Charts-Pr√ºfung: alle {config['charts_check_interval']} Stunden")
        print(f"üí∞ Preis-Updates: alle {config['price_update_interval']} Stunden") 
        print(f"‚è≥ Nachverfolgung: {config['track_after_removal_days']} Tage nach Chart-Entfernung")
        print(f"üßπ Bereinigung: alle {config['cleanup_interval_hours']} Stunden")
        
        print("\nüìã KONFIGURATION:")
        print("1. üöÄ Automation starten" if not automation_active else "1. üõë Automation stoppen")
        print("2. üìä Charts-Pr√ºfung Intervall √§ndern")
        print("3. üí∞ Preis-Update Intervall √§ndern")
        print("4. ‚è≥ Nachverfolgungszeit √§ndern")
        print("5. üßπ Bereinigung-Intervall √§ndern")
        print("6. üìà Erweiterte Statistiken")
        print("7. üîÑ Konfiguration zur√ºcksetzen")
        print("0. ‚Ü©Ô∏è Zur√ºck")
        
        choice = safe_input("\nOption w√§hlen: ")
        
        if choice == "0":
            break
        elif choice == "1":
            if automation_active:
                if hasattr(charts_manager, 'stop_automation'):
                    charts_manager.stop_automation()
                    print("üõë Charts-Automation gestoppt")
            else:
                # Konfiguration anwenden
                charts_manager.charts_check_interval = config['charts_check_interval']
                charts_manager.price_update_interval = config['price_update_interval']
                charts_manager.track_after_removal_days = config['track_after_removal_days']
                charts_manager.cleanup_interval_hours = config['cleanup_interval_hours']
                
                if hasattr(charts_manager, 'start_automation'):
                    charts_manager.start_automation()
                    print("üöÄ Charts-Automation mit neuer Konfiguration gestartet")
        
        elif choice == "2":
            print(f"\nüìä CHARTS-PR√úFUNG INTERVALL")
            print(f"Aktuell: alle {config['charts_check_interval']} Stunden")
            new_val = safe_input("Neuer Intervall (1-24 Stunden): ")
            try:
                new_val = int(new_val)
                if 1 <= new_val <= 24:
                    config['charts_check_interval'] = new_val
                    print(f"‚úÖ Charts-Pr√ºfung auf {new_val} Stunden gesetzt")
                else:
                    print("‚ùå Ung√ºltiger Wert (1-24)")
            except ValueError:
                print("‚ùå Ung√ºltige Eingabe")
        
        elif choice == "3":
            print(f"\nüí∞ PREIS-UPDATE INTERVALL")
            print(f"Aktuell: alle {config['price_update_interval']} Stunden")
            new_val = safe_input("Neuer Intervall (1-48 Stunden): ")
            try:
                new_val = int(new_val)
                if 1 <= new_val <= 48:
                    config['price_update_interval'] = new_val
                    print(f"‚úÖ Preis-Updates auf {new_val} Stunden gesetzt")
                else:
                    print("‚ùå Ung√ºltiger Wert (1-48)")
            except ValueError:
                print("‚ùå Ung√ºltige Eingabe")
        
        elif choice == "4":
            print(f"\n‚è≥ NACHVERFOLGUNGSZEIT")
            print(f"Aktuell: {config['track_after_removal_days']} Tage")
            print("Wie lange sollen Spiele weiter getrackt werden, nachdem sie aus den Charts verschwunden sind?")
            new_val = safe_input("Neue Anzahl Tage (1-30): ")
            try:
                new_val = int(new_val)
                if 1 <= new_val <= 30:
                    config['track_after_removal_days'] = new_val
                    print(f"‚úÖ Nachverfolgung auf {new_val} Tage gesetzt")
                else:
                    print("‚ùå Ung√ºltiger Wert (1-30)")
            except ValueError:
                print("‚ùå Ung√ºltige Eingabe")
        
        elif choice == "5":
            print(f"\nüßπ BEREINIGUNG-INTERVALL")
            print(f"Aktuell: alle {config['cleanup_interval_hours']} Stunden")
            print("Wie oft sollen abgelaufene Chart-Titel entfernt werden?")
            new_val = safe_input("Neuer Intervall (6-168 Stunden): ")
            try:
                new_val = int(new_val)
                if 6 <= new_val <= 168:  # 6h bis 1 Woche
                    config['cleanup_interval_hours'] = new_val
                    print(f"‚úÖ Bereinigung auf {new_val} Stunden gesetzt")
                else:
                    print("‚ùå Ung√ºltiger Wert (6-168)")
            except ValueError:
                print("‚ùå Ung√ºltige Eingabe")
        
        elif choice == "6":
            print("\nüìà ERWEITERTE STATISTIKEN:")
            if hasattr(charts_manager, 'last_charts_check'):
                print(f"üïí Letzte Charts-Pr√ºfung: {charts_manager.last_charts_check}")
            if hasattr(charts_manager, 'charts_update_count'):
                print(f"üìä Charts-Updates: {charts_manager.charts_update_count}")
            if hasattr(charts_manager, 'price_update_count'):
                print(f"üí∞ Preis-Updates: {charts_manager.price_update_count}")
            if hasattr(charts_manager, 'cleanup_count'):
                print(f"üßπ Bereinigungen: {charts_manager.cleanup_count}")
            
            # Aktuelle Chart-Titel z√§hlen
            try:
                with tracker.db_manager.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute("SELECT COUNT(*) FROM chart_games WHERE active = 1")
                    active_charts = cursor.fetchone()[0]
                    cursor.execute("SELECT COUNT(*) FROM chart_games WHERE active = 0")
                    inactive_charts = cursor.fetchone()[0]
                    print(f"üìä Aktive Chart-Titel: {active_charts}")
                    print(f"‚è∏Ô∏è Inaktive Chart-Titel: {inactive_charts}")
            except:
                print("‚ùå Statistiken nicht verf√ºgbar")
        
        elif choice == "7":
            confirm = safe_input("Konfiguration auf Standard zur√ºcksetzen? (j/n): ")
            if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                config = {
                    'charts_check_interval': 2,
                    'price_update_interval': 6,
                    'track_after_removal_days': 7,
                    'cleanup_interval_hours': 24
                }
                print("‚úÖ Konfiguration zur√ºckgesetzt")
        
        input("\nDr√ºcke Enter zum Fortfahren...")

# Elasticsearch-Funktionen (18-22)
def menu_elasticsearch_export(es_manager, tracker):
    """Option 18: Daten zu Elasticsearch exportieren"""
    print("\nüìä ELASTICSEARCH-EXPORT")
    print("=" * 27)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        print("üí° Installiere Elasticsearch f√ºr erweiterte Analytics")
        return
    
    try:
        apps = get_tracked_apps_safe(tracker)
        if not apps:
            print("‚ùå Keine Daten f√ºr Export verf√ºgbar")
            return
        
        print(f"üîÑ Exportiere {len(apps)} Apps zu Elasticsearch...")
        
        if hasattr(es_manager, 'export_data'):
            success = es_manager.export_data(apps)
            if success:
                print("‚úÖ Daten erfolgreich zu Elasticsearch exportiert!")
            else:
                print("‚ùå Export fehlgeschlagen")
        else:
            print("‚ùå Export-Funktion nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Elasticsearch-Export: {e}")

def menu_elasticsearch_dashboard(es_manager):
    """Option 19: Elasticsearch-Dashboard √∂ffnen"""
    print("\nüîç ELASTICSEARCH-DASHBOARD")
    print("=" * 29)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    try:
        if hasattr(es_manager, 'open_dashboard'):
            es_manager.open_dashboard()
            print("üåê Dashboard ge√∂ffnet im Browser")
        else:
            print("üåê Dashboard-URL: http://localhost:5601")
            print("üí° √ñffnen Sie die URL manuell im Browser")
    
    except Exception as e:
        print(f"‚ùå Fehler beim √ñffnen des Dashboards: {e}")

def menu_elasticsearch_analytics(es_manager):
    """Option 20: Elasticsearch-Analytics"""
    print("\nüìà ELASTICSEARCH-ANALYTICS")
    print("=" * 29)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    try:
        if hasattr(es_manager, 'get_analytics'):
            analytics = es_manager.get_analytics()
            
            print("üìä Analytics-√úbersicht:")
            print(f"üìà Indexierte Dokumente: {analytics.get('total_docs', 0)}")
            print(f"üè™ Stores analysiert: {analytics.get('stores_count', 0)}")
            print(f"üìÖ Zeitraum: {analytics.get('date_range', 'N/A')}")
            
            top_games = analytics.get('top_games', [])
            if top_games:
                print("\nüéÆ Top Spiele:")
                for i, game in enumerate(top_games[:5], 1):
                    name = game.get('name', 'Unbekannt')[:30]
                    avg_price = game.get('avg_price', 0)
                    print(f"{i}. {name} (√ò ‚Ç¨{avg_price:.2f})")
        else:
            print("‚ùå Analytics-Funktion nicht verf√ºgbar")
    
    except Exception as e:
        print(f"‚ùå Fehler bei Elasticsearch-Analytics: {e}")

def menu_elasticsearch_config(es_manager):
    """Option 21: Elasticsearch-Konfiguration"""
    print("\n‚öôÔ∏è ELASTICSEARCH-KONFIGURATION")
    print("=" * 33)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    try:
        # Status anzeigen
        if hasattr(es_manager, 'get_status'):
            status = es_manager.get_status()
            print(f"üîç Status: {'üü¢ Verbunden' if status.get('connected') else 'üî¥ Getrennt'}")
            print(f"üåê Host: {status.get('host', 'localhost:9200')}")
            print(f"üìä Indizes: {status.get('indices_count', 0)}")
        
        print("\n‚öôÔ∏è Konfigurationsoptionen:")
        print("1. Verbindung testen")
        print("2. Indizes neu erstellen")
        print("3. Mapping anzeigen")
        print("0. Zur√ºck")
        
        choice = safe_input("Option w√§hlen: ")
        
        if choice == "1":
            if hasattr(es_manager, 'test_connection'):
                connected = es_manager.test_connection()
                print(f"üîç Verbindungstest: {'‚úÖ Erfolgreich' if connected else '‚ùå Fehlgeschlagen'}")
        elif choice == "2":
            if hasattr(es_manager, 'recreate_indices'):
                success = es_manager.recreate_indices()
                print(f"üìä Indizes neu erstellt: {'‚úÖ Erfolgreich' if success else '‚ùå Fehlgeschlagen'}")
        elif choice == "3":
            if hasattr(es_manager, 'show_mapping'):
                es_manager.show_mapping()
    
    except Exception as e:
        print(f"‚ùå Fehler bei Elasticsearch-Konfiguration: {e}")

def menu_elasticsearch_sync(es_manager, tracker):
    """Option 22: Automatische ES-Synchronisation"""
    print("\nüîÑ ELASTICSEARCH AUTO-SYNC")
    print("=" * 30)
    
    if not es_manager:
        print("‚ùå Elasticsearch Manager nicht verf√ºgbar")
        return
    
    try:
        # Sync-Status pr√ºfen
        sync_active = False
        if hasattr(es_manager, 'is_sync_active'):
            sync_active = es_manager.is_sync_active()
        
        print(f"üîç Auto-Synchronisation: {'üü¢ AKTIV' if sync_active else 'üî¥ INAKTIV'}")
        
        if sync_active:
            choice = safe_input("Auto-Synchronisation stoppen? (j/n): ")
            if choice.lower() in ['j', 'ja', 'y', 'yes']:
                if hasattr(es_manager, 'stop_sync'):
                    es_manager.stop_sync()
                    print("üõë Auto-Synchronisation gestoppt")
        else:
            choice = safe_input("Auto-Synchronisation starten? (j/n): ")
            if choice.lower() in ['j', 'ja', 'y', 'yes']:
                if hasattr(es_manager, 'start_sync'):
                    es_manager.start_sync()
                    print("üöÄ Auto-Synchronisation gestartet")
    
    except Exception as e:
        print(f"‚ùå Fehler bei ES Auto-Sync: {e}")

# System-Tools (23-27)
def menu_process_management():
    """Option 23: Process Management Terminal"""
    print("\nüîß PROCESS MANAGEMENT TERMINAL")
    print("=" * 34)
    
    while True:
        print("\nüñ•Ô∏è Process Management:")
        print("1. üìä Laufende Prozesse anzeigen")
        print("2. üîç Steam Price Tracker Prozesse")
        print("3. üõë Prozess beenden")
        print("4. üìà Ressourcenverbrauch")
        print("0. ‚Ü©Ô∏è Zur√ºck")
        
        choice = safe_input("Option w√§hlen: ")
        
        if choice == "0":
            break
        elif choice == "1":
            # Laufende Prozesse
            try:
                import psutil
                processes = []
                for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_info']):
                    try:
                        proc_info = proc.info
                        if 'python' in proc_info['name'].lower():
                            processes.append(proc_info)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass
                
                if processes:
                    print("\nüêç Python-Prozesse:")
                    for proc in processes[:10]:
                        pid = proc['pid']
                        name = proc['name']
                        cpu = proc['cpu_percent']
                        memory = proc['memory_info'].rss / (1024*1024) if proc['memory_info'] else 0
                        print(f"PID {pid}: {name} (CPU: {cpu}%, RAM: {memory:.1f} MB)"); print(f"   üìã Steam Price Tracker Prozess") if pid == __import__("os").getpid() else None
                else:
                    print("‚ùå Keine Python-Prozesse gefunden")
            except ImportError:
                print("‚ùå psutil nicht verf√ºgbar")
            except Exception as e:
                print(f"‚ùå Fehler beim Anzeigen der Prozesse: {e}")
        
        elif choice == "2":
            # Steam Price Tracker Prozesse
            print("üîç Suche nach Steam Price Tracker Prozessen...")
            # TODO: Implementiere spezifische Prozesssuche
            print("üí° Feature in Entwicklung")
        
        elif choice == "3":
            # Prozess beenden
            pid = safe_input("Prozess-ID (PID) zum Beenden: ")
            try:
                pid = int(pid)
                import psutil
                proc = psutil.Process(pid)
                proc_name = proc.name()
                
                confirm = safe_input(f"Prozess '{proc_name}' (PID {pid}) wirklich beenden? (j/n): ")
                if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                    proc.terminate()
                    print(f"‚úÖ Prozess {pid} beendet")
            except ValueError:
                print("‚ùå Ung√ºltige PID")
            except ImportError:
                print("‚ùå psutil nicht verf√ºgbar")
            except Exception as e:
                print(f"‚ùå Fehler beim Beenden des Prozesses: {e}")
        
        elif choice == "4":
            # Ressourcenverbrauch
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('.')
                
                print(f"\nüìä Systemressourcen:")
                print(f"üñ•Ô∏è CPU: {cpu_percent}%")
                print(f"üíæ RAM: {memory.percent}% ({memory.available / (1024**3):.1f} GB frei)")
                print(f"üíø Festplatte: {disk.percent}% ({disk.free / (1024**3):.1f} GB frei)")
            except ImportError:
                print("‚ùå psutil nicht verf√ºgbar")
            except Exception as e:
                print(f"‚ùå Fehler beim Abrufen der Ressourcen: {e}")
        
        input("\nDr√ºcke Enter zum Fortfahren...")

def menu_batch_processing(tracker):
    """Option 24: Batch Processing"""
    print("\nüì¶ BATCH PROCESSING")
    print("=" * 20)
    
    while True:
        print("\nüîÑ Batch-Operationen:")
        print("1. üìä Batch Preis-Update")
        print("2. üßπ Batch Datenbereinigung")
        print("3. üìÑ Batch CSV-Export")
        print("4. üîç Batch App-Validierung")
        print("0. ‚Ü©Ô∏è Zur√ºck")
        
        choice = safe_input("Batch-Operation w√§hlen: ")
        
        if choice == "0":
            break
        elif choice == "1":
            # Batch Preis-Update
            batch_size = safe_input("Batch-Gr√∂√üe (Standard: 10): ")
            try:
                batch_size = int(batch_size) if batch_size else 10
                
                apps = get_tracked_apps_safe(tracker)
                if not apps:
                    print("‚ùå Keine Apps f√ºr Batch-Update gefunden")
                    continue
                
                print(f"üîÑ Starte Batch-Update f√ºr {len(apps)} Apps (Batch-Gr√∂√üe: {batch_size})...")
                
                updated = 0
                for i in range(0, len(apps), batch_size):
                    batch = apps[i:i+batch_size]
                    print(f"üìä Batch {i//batch_size + 1}: Apps {i+1}-{min(i+batch_size, len(apps))}")
                    
                    for app in batch:
                        app_id = app.get('steam_app_id')
                        try:
                            # Einfaches Update (implementierung abh√§ngig von verf√ºgbaren Methoden)
                            if hasattr(tracker, 'track_app_prices'):
                                result = tracker.track_app_prices([app_id])
                                if result:
                                    updated += 1
                                    print(f"   ‚úÖ {app.get('name', 'Unbekannt')[:20]}")
                                else:
                                    print(f"   ‚ùå {app.get('name', 'Unbekannt')[:20]}")
                            time.sleep(0.5)  # Rate limiting
                        except Exception as e:
                            print(f"   ‚ùå {app.get('name', 'Unbekannt')[:20]} - {e}")
                    
                    # Pause zwischen Batches
                    if i + batch_size < len(apps):
                        time.sleep(2)
                
                print(f"‚úÖ Batch-Update abgeschlossen: {updated}/{len(apps)} Apps aktualisiert")
            
            except ValueError:
                print("‚ùå Ung√ºltige Batch-Gr√∂√üe")
            except KeyboardInterrupt:
                print("\n‚èπÔ∏è Batch-Update abgebrochen")
            except Exception as e:
                print(f"‚ùå Fehler beim Batch-Update: {e}")
        
        elif choice == "2":
            # Batch Datenbereinigung
            print("üßπ Starte Batch-Datenbereinigung...")
            try:
                removed_snapshots = 0
                removed_apps = 0
                
                # Alte Snapshots bereinigen
                if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'cleanup_old_prices'):
                    removed_snapshots = tracker.db_manager.cleanup_old_prices(90)
                
                # Inaktive Apps bereinigen
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute("DELETE FROM tracked_apps WHERE active = 0")
                        removed_apps = cursor.rowcount
                        conn.commit()
                
                print(f"‚úÖ Bereinigung abgeschlossen:")
                print(f"   üì∏ {removed_snapshots} alte Snapshots entfernt")
                print(f"   üéÆ {removed_apps} inaktive Apps entfernt")
            
            except Exception as e:
                print(f"‚ùå Fehler bei Datenbereinigung: {e}")
        
        elif choice == "3":
            # Batch CSV-Export
            print("üìÑ Erstelle erweiterten CSV-Export...")
            try:
                apps = get_tracked_apps_safe(tracker)
                filename = f"batch_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                
                with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                    fieldnames = ['Steam_App_ID', 'Name', 'Source', 'Added_At', 'Active', 
                                'Latest_Steam_Price', 'Latest_GMG_Price', 'Latest_GOG_Price', 'Last_Update']
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    writer.writeheader()
                    
                    for app in apps:
                        app_id = app.get('steam_app_id')
                        
                        # Neueste Preise holen
                        latest_prices = {'steam': 'N/A', 'gmg': 'N/A', 'gog': 'N/A'}
                        try:
                            if hasattr(tracker, 'db_manager'):
                                with tracker.db_manager.get_connection() as conn:
                                    cursor = conn.cursor()
                                    cursor.execute("""
                                        SELECT steam_price, greenmangaming_price, gog_price, timestamp
                                        FROM price_snapshots 
                                        WHERE steam_app_id = ? 
                                        ORDER BY timestamp DESC LIMIT 1
                                    """, (app_id,))
                                    result = cursor.fetchone()
                                    if result:
                                        latest_prices['steam'] = result[0] or 'N/A'
                                        latest_prices['gmg'] = result[1] or 'N/A'
                                        latest_prices['gog'] = result[2] or 'N/A'
                        except Exception:
                            pass
                        
                        writer.writerow({
                            'Steam_App_ID': app_id,
                            'Name': app.get('name', ''),
                            'Source': app.get('source', 'manual'),
                            'Added_At': app.get('added_at', ''),
                            'Active': app.get('active', True),
                            'Latest_Steam_Price': latest_prices['steam'],
                            'Latest_GMG_Price': latest_prices['gmg'],
                            'Latest_GOG_Price': latest_prices['gog'],
                            'Last_Update': app.get('last_price_update', '')
                        })
                
                print(f"‚úÖ Erweiterter CSV-Export erstellt: {filename}")
                print(f"üìä {len(apps)} Apps mit Preisdaten exportiert")
            
            except Exception as e:
                print(f"‚ùå Fehler beim Batch-Export: {e}")
        
        elif choice == "4":
            # Batch App-Validierung
            print("üîç Starte App-Validierung...")
            try:
                apps = get_tracked_apps_safe(tracker)
                valid = 0
                invalid = 0
                
                for app in apps:
                    app_id = app.get('steam_app_id')
                    name = app.get('name', 'Unbekannt')
                    
                    # Einfache Validierung
                    if app_id and app_id.isdigit() and len(app_id) > 0:
                        valid += 1
                        print(f"‚úÖ {name[:30]} ({app_id})")
                    else:
                        invalid += 1
                        print(f"‚ùå {name[:30]} ({app_id}) - Ung√ºltige App ID")
                
                print(f"\nüìä Validierung abgeschlossen:")
                print(f"   ‚úÖ {valid} g√ºltige Apps")
                print(f"   ‚ùå {invalid} ung√ºltige Apps")
            
            except Exception as e:
                print(f"‚ùå Fehler bei App-Validierung: {e}")
        
        input("\nDr√ºcke Enter zum Fortfahren...")

def menu_database_maintenance(tracker):
    """Option 25: Datenbank-Wartung"""
    print("\nüßπ DATENBANK-WARTUNG")
    print("=" * 21)
    
    while True:
        print("\nüóÉÔ∏è Wartungsoptionen:")
        print("1. üìä Datenbank-Analyse")
        print("2. üîß Tabellen reparieren")
        print("3. üìà Index-Optimierung")
        print("4. üßπ Duplikate entfernen")
        print("5. üìè Tabellengr√∂√üe anzeigen")
        print("0. ‚Ü©Ô∏è Zur√ºck")
        
        choice = safe_input("Wartungsoption w√§hlen: ")
        
        if choice == "0":
            break
        elif choice == "1":
            # Datenbank-Analyse
            try:
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        
                        print("\nüìä DATENBANK-ANALYSE:")
                        
                        # Tabellen-Info
                        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                        tables = [row[0] for row in cursor.fetchall()]
                        print(f"üìã Tabellen: {len(tables)}")
                        
                        for table in tables:
                            cursor.execute(f"SELECT COUNT(*) FROM {table}")
                            count = cursor.fetchone()[0]
                            
                            # Tabellengr√∂√üe (approximativ)
                            cursor.execute(f"SELECT sql FROM sqlite_master WHERE name='{table}'")
                            schema = cursor.fetchone()
                            
                            print(f"   {table}: {count} Eintr√§ge")
                        
                        # Index-Info
                        cursor.execute("SELECT name FROM sqlite_master WHERE type='index'")
                        indices = [row[0] for row in cursor.fetchall()]
                        print(f"üîç Indizes: {len(indices)}")
                        
                        # Pragma-Informationen
                        cursor.execute("PRAGMA integrity_check")
                        integrity = cursor.fetchone()[0]
                        print(f"üîç Integrit√§t: {integrity}")
            
            except Exception as e:
                print(f"‚ùå Fehler bei Datenbank-Analyse: {e}")
        
        elif choice == "2":
            # Tabellen reparieren
            print("üîß F√ºhre Integrit√§tspr√ºfung durch...")
            try:
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        
                        # Integrit√§tspr√ºfung
                        cursor.execute("PRAGMA integrity_check")
                        result = cursor.fetchone()[0]
                        
                        if result == "ok":
                            print("‚úÖ Datenbank ist integer")
                        else:
                            print(f"‚ö†Ô∏è Integrit√§tsprobleme gefunden: {result}")
                            
                            # Quick Fix versuchen
                            cursor.execute("PRAGMA quick_check")
                            quick_result = cursor.fetchone()[0]
                            print(f"üîß Quick Check: {quick_result}")
            
            except Exception as e:
                print(f"‚ùå Fehler bei Tabellen-Reparatur: {e}")
        
        elif choice == "3":
            # Index-Optimierung
            print("üìà Optimiere Indizes...")
            try:
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        
                        # Empfohlene Indizes pr√ºfen/erstellen
                        recommended_indices = [
                            "CREATE INDEX IF NOT EXISTS idx_tracked_apps_active ON tracked_apps(active)",
                            "CREATE INDEX IF NOT EXISTS idx_snapshots_app_timestamp ON price_snapshots(steam_app_id, timestamp)",
                            "CREATE INDEX IF NOT EXISTS idx_snapshots_timestamp ON price_snapshots(timestamp)"
                        ]
                        
                        created = 0
                        for index_sql in recommended_indices:
                            try:
                                cursor.execute(index_sql)
                                created += 1
                            except Exception as e:
                                print(f"Index bereits vorhanden: {e}")
                        
                        conn.commit()
                        print(f"‚úÖ {created} Indizes optimiert/erstellt")
                        
                        # ANALYZE ausf√ºhren
                        cursor.execute("ANALYZE")
                        print("‚úÖ Statistiken aktualisiert")
            
            except Exception as e:
                print(f"‚ùå Fehler bei Index-Optimierung: {e}")
        
        elif choice == "4":
            # Duplikate entfernen
            print("üßπ Suche nach Duplikaten...")
            try:
                if hasattr(tracker, 'db_manager'):
                    with tracker.db_manager.get_connection() as conn:
                        cursor = conn.cursor()
                        
                        # Duplikate in tracked_apps
                        cursor.execute("""
                            SELECT steam_app_id, COUNT(*) as count
                            FROM tracked_apps 
                            GROUP BY steam_app_id 
                            HAVING count > 1
                        """)
                        app_duplicates = cursor.fetchall()
                        
                        if app_duplicates:
                            print(f"üîç {len(app_duplicates)} Duplikate in tracked_apps gefunden")
                            
                            confirm = safe_input("Duplikate entfernen? (j/n): ")
                            if confirm.lower() in ['j', 'ja', 'y', 'yes']:
                                removed = 0
                                for app_id, count in app_duplicates:
                                    # Neueste behalten, √§ltere l√∂schen
                                    cursor.execute("""
                                        DELETE FROM tracked_apps 
                                        WHERE steam_app_id = ? AND rowid NOT IN (
                                            SELECT rowid FROM tracked_apps 
                                            WHERE steam_app_id = ? 
                                            ORDER BY added_at DESC LIMIT 1
                                        )
                                    """, (app_id, app_id))
                                    removed += cursor.rowcount
                                
                                conn.commit()
                                print(f"‚úÖ {removed} Duplikate entfernt")
                        else:
                            print("‚úÖ Keine Duplikate gefunden")
            
            except Exception as e:
                print(f"‚ùå Fehler beim Entfernen von Duplikaten: {e}")
        
        elif choice == "5":
            # Tabellengr√∂√üe anzeigen
            try:
                if hasattr(tracker, 'db_manager'):
                    db_path = getattr(tracker.db_manager, 'db_path', 'steam_price_tracker.db')
                    if os.path.exists(db_path):
                        total_size = os.path.getsize(db_path)
                        print(f"\nüíæ Gesamtgr√∂√üe: {total_size / (1024*1024):.2f} MB")
                        
                        with tracker.db_manager.get_connection() as conn:
                            cursor = conn.cursor()
                            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                            tables = [row[0] for row in cursor.fetchall()]
                            
                            for table in tables:
                                cursor.execute(f"SELECT COUNT(*) FROM {table}")
                                count = cursor.fetchone()[0]
                                
                                # Approximative Gr√∂√üe pro Tabelle
                                estimated_size = count * 100  # Grobe Sch√§tzung
                                print(f"üìä {table}: {count} Eintr√§ge (~{estimated_size/1024:.1f} KB)")
                    else:
                        print("‚ùå Datenbankdatei nicht gefunden")
            
            except Exception as e:
                print(f"‚ùå Fehler beim Anzeigen der Tabellengr√∂√üe: {e}")
        
        input("\nDr√ºcke Enter zum Fortfahren...")

def menu_create_backup(tracker):
    """Option 26: Backup erstellen"""
    print("\nüíæ BACKUP ERSTELLEN")
    print("=" * 19)
    
    try:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_name = f"steam_tracker_backup_{timestamp}"
        
        print("üì¶ Erstelle vollst√§ndiges System-Backup...")
        
        # Datenbank-Backup
        db_backup = f"{backup_name}.db"
        config_backup = f"{backup_name}_config.zip"
        
        backup_success = False
        
        # Datenbank sichern
        if hasattr(tracker, 'db_manager') and hasattr(tracker.db_manager, 'backup_database'):
            success = tracker.db_manager.backup_database(db_backup)
            if success:
                print(f"‚úÖ Datenbank gesichert: {db_backup}")
                backup_success = True
            else:
                print("‚ùå Datenbank-Backup fehlgeschlagen")
        else:
            # Fallback: Datei kopieren
            try:
                import shutil
                db_path = getattr(tracker.db_manager, 'db_path', 'steam_price_tracker.db')
                if os.path.exists(db_path):
                    shutil.copy2(db_path, db_backup)
                    print(f"‚úÖ Datenbank gesichert: {db_backup}")
                    backup_success = True
            except Exception as e:
                print(f"‚ùå Datenbank-Backup fehlgeschlagen: {e}")
        
        # Konfigurationsdateien sichern
        try:
            import zipfile
            config_files = ['.env', 'config.json', 'setup_report.json']
            
            with zipfile.ZipFile(config_backup, 'w') as zipf:
                files_added = 0
                for config_file in config_files:
                    if os.path.exists(config_file):
                        zipf.write(config_file)
                        files_added += 1
                
                if files_added > 0:
                    print(f"‚úÖ Konfiguration gesichert: {config_backup} ({files_added} Dateien)")
                else:
                    os.remove(config_backup)
                    print("‚ÑπÔ∏è Keine Konfigurationsdateien zum Sichern gefunden")
        
        except Exception as e:
            print(f"‚ö†Ô∏è Konfiguration-Backup fehlgeschlagen: {e}")
        
        # Backup-Info erstellen
        if backup_success:
            backup_info = {
                'timestamp': timestamp,
                'database_backup': db_backup,
                'config_backup': config_backup if os.path.exists(config_backup) else None,
                'apps_count': len(get_tracked_apps_safe(tracker)),
                'stats': get_statistics_safe(tracker)
            }
            
            info_file = f"{backup_name}_info.json"
            with open(info_file, 'w', encoding='utf-8') as f:
                json.dump(backup_info, f, indent=2, default=str)
            
            print(f"‚úÖ Backup-Info erstellt: {info_file}")
            print(f"\nüì¶ Backup abgeschlossen!")
            print(f"üìÇ Backup-Dateien:")
            print(f"   üóÉÔ∏è {db_backup}")
            if os.path.exists(config_backup):
                print(f"   ‚öôÔ∏è {config_backup}")
            print(f"   üìã {info_file}")
        else:
            print("‚ùå Backup fehlgeschlagen")
    
    except Exception as e:
        print(f"‚ùå Fehler beim Backup: {e}")

def menu_edit_configuration():
    """Option 27: Konfiguration bearbeiten"""
    print("\n‚öôÔ∏è KONFIGURATION BEARBEITEN")
    print("=" * 30)
    
    config_files = {
        '1': ('.env', 'Umgebungsvariablen'),
        '2': ('config.json', 'Anwendungskonfiguration'),
        '3': ('setup_report.json', 'Setup-Bericht (nur lesen)')
    }
    
    print("üìù Verf√ºgbare Konfigurationsdateien:")
    for key, (filename, description) in config_files.items():
        status = "‚úÖ" if os.path.exists(filename) else "‚ùå"
        print(f"{key}. {status} {description} ({filename})")
    
    print("4. üÜï Neue .env-Datei erstellen")
    print("0. ‚Ü©Ô∏è Zur√ºck")
    
    choice = safe_input("Datei ausw√§hlen: ")
    
    if choice == "0":
        return
    elif choice == "4":
        # Neue .env erstellen
        print("\nüÜï Erstelle neue .env-Datei...")
        try:
            steam_api_key = safe_input("Steam API Key: ")
            
            env_content = f"""# Steam Price Tracker Konfiguration
# Erstellt am: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

# Steam Web API Key (erforderlich)
STEAM_API_KEY={steam_api_key}

# Optional: Steam User ID f√ºr Wishlist-Import
STEAM_USER_ID=

# Optional: Datenbank-Pfad
DATABASE_PATH=steam_price_tracker.db

# Optional: Logging-Level (DEBUG, INFO, WARNING, ERROR)
LOG_LEVEL=INFO

# Optional: Automatische Pr√ºfung (Stunden)
AUTO_CHECK_INTERVAL=6

# Optional: Maximum gleichzeitige API-Calls
MAX_CONCURRENT_REQUESTS=5

# Optional: Request-Delay (Sekunden)
REQUEST_DELAY=1
"""
            
            with open('.env', 'w', encoding='utf-8') as f:
                f.write(env_content)
            
            print("‚úÖ .env-Datei erstellt!")
            print("üí° Sie k√∂nnen die Datei manuell mit einem Texteditor bearbeiten")
        
        except Exception as e:
            print(f"‚ùå Fehler beim Erstellen der .env-Datei: {e}")
    
    elif choice in config_files:
        filename, description = config_files[choice]
        
        if not os.path.exists(filename):
            print(f"‚ùå Datei '{filename}' nicht gefunden")
            return
        
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                content = f.read()
            
            print(f"\nüìÑ INHALT VON {filename}:")
            print("=" * 50)
            print(content)
            print("=" * 50)
            
            if filename.endswith('.json'):
                # JSON-Dateien nur anzeigen
                print("‚ÑπÔ∏è JSON-Dateien werden nur angezeigt (schreibgesch√ºtzt)")
                print("üí° Verwenden Sie einen Texteditor f√ºr √Ñnderungen")
            else:
                # .env-Dateien k√∂nnen bearbeitet werden
                edit_choice = safe_input("\nDatei bearbeiten? (j/n): ")
                if edit_choice.lower() in ['j', 'ja', 'y', 'yes']:
                    print("üí° Verwenden Sie einen Texteditor wie notepad, nano oder vim")
                    print(f"üí° Datei-Pfad: {os.path.abspath(filename)}")
                    
                    # Optional: Versuch, Standard-Editor zu √∂ffnen
                    try:
                        if sys.platform == "win32":
                            os.startfile(filename)
                        elif sys.platform == "darwin":
                            subprocess.call(["open", filename])
                        else:
                            subprocess.call(["xdg-open", filename])
                        print("‚úÖ Datei im Standard-Editor ge√∂ffnet")
                    except Exception:
                        print("‚ùå Konnte Standard-Editor nicht √∂ffnen")
        
        except Exception as e:
            print(f"‚ùå Fehler beim Laden der Konfiguration: {e}")

# =================================================================
# MAIN APPLICATION LOOP
# =================================================================

def main():
    """Hauptfunktion mit vollst√§ndigem 27-Option Men√º"""
    
    print("üéÆ STEAM PRICE TRACKER")
    print("=" * 25)
    print("üöÄ Initialisiere System...")
    
    # Tracker mit Fallbacks initialisieren
    tracker, charts_manager, es_manager = create_tracker_with_fallback()
    
    if not tracker:
        print("‚ùå Kritischer Fehler: Price Tracker konnte nicht initialisiert werden")
        print("üí° Pr√ºfen Sie die Installation und Dependencies")
        return
    
    # Features-Status
    charts_enabled = bool(charts_manager)
    es_available = bool(es_manager)
    
    print(f"‚úÖ System initialisiert!")
    print(f"üìä Charts: {'‚úÖ Verf√ºgbar' if charts_enabled else '‚ùå Nicht verf√ºgbar'}")
    print(f"üîç Elasticsearch: {'‚úÖ Verf√ºgbar' if es_available else '‚ùå Nicht verf√ºgbar'}")
    
    # Hauptmen√º-Loop
    while True:
        try:
            print("\n" + "=" * 60)
            print("üéÆ STEAM PRICE TRACKER - HAUPTMEN√ú")
            print("=" * 60)
            
            # Basis-Funktionen (1-12)
            print("\nüîß BASIS-FUNKTIONEN:")
            print("1.  üì± App manuell zum Tracking hinzuf√ºgen")
            print("2.  üì• Steam Wishlist importieren")
            print("3.  üîç Aktuelle Preise anzeigen")
            print("4.  üìä Beste Deals anzeigen")
            print("5.  üìà Preisverlauf anzeigen")
            print("6.  üîÑ Preise manuell aktualisieren")
            print("7.  üöÄ Automatisches Tracking starten/stoppen")
            print("8.  üìã Getrackte Apps verwalten")
            print("9.  üóëÔ∏è Apps entfernen")
            print("10. üìÑ CSV-Export erstellen")
            print("11. üìä Detaillierte Statistiken")
            print("12. ‚öôÔ∏è System-Tools & Wartung")
            
            # Charts-Funktionen (13-17)
            if charts_enabled:
                print("\nüìä CHARTS-FUNKTIONEN:")
                print("13. üèÜ Steam Charts anzeigen")
                print("14. üìà Charts sofort aktualisieren")
                print("15. üéØ Charts-Deals anzeigen")
                print("16. üìä Charts-Statistiken")
                print("17. üîÑ Charts automatisch tracken")
            else:
                print("\nüìä CHARTS-FUNKTIONEN: ‚ùå Nicht verf√ºgbar")
            
            # Elasticsearch-Funktionen (18-22)
            if es_available:
                print("\nüîç ELASTICSEARCH-FUNKTIONEN:")
                print("18. üìä Daten zu Elasticsearch exportieren")
                print("19. üîç Elasticsearch-Dashboard √∂ffnen")
                print("20. üìà Elasticsearch-Analytics")
                print("21. ‚öôÔ∏è Elasticsearch-Konfiguration")
                print("22. üîÑ Automatische ES-Synchronisation")
            else:
                print("\nüîç ELASTICSEARCH-FUNKTIONEN: ‚ùå Nicht verf√ºgbar")
            
            # System-Tools (23-27)
            print("\nüõ†Ô∏è ERWEITERTE SYSTEM-TOOLS:")
            print("23. üîß Process Management Terminal")
            print("24. üì¶ Batch Processing")
            print("25. üßπ Datenbank-Wartung")
            print("26. üíæ Backup erstellen")
            print("27. ‚öôÔ∏è Konfiguration bearbeiten")
            
            print("\n0.  üëã Beenden")
            print("=" * 60)
            
            # Eingabe
            choice = safe_input("W√§hlen Sie eine Option (0-27): ")
            
            # Menu-Handler
            if choice == "0":
                print("\nüëã Auf Wiedersehen!")
                print("üßπ Enhanced Cleanup wird ausgef√ºhrt...")
                enhanced_cleanup()
                break
            
            # Basis-Funktionen (1-12)
            elif choice == "1":
                menu_add_app_manually(tracker)
            elif choice == "2":
                menu_import_wishlist(tracker)
            elif choice == "3":
                menu_show_current_prices(tracker)
            elif choice == "4":
                menu_show_best_deals(tracker)
            elif choice == "5":
                menu_show_price_history(tracker)
            elif choice == "6":
                menu_update_prices(tracker)
            elif choice == "7":
                menu_toggle_scheduler(tracker)
            elif choice == "8":
                menu_manage_apps(tracker)
            elif choice == "9":
                menu_remove_apps(tracker)
            elif choice == "10":
                menu_csv_export(tracker)
            elif choice == "11":
                menu_detailed_statistics(tracker)
            elif choice == "12":
                menu_system_tools(tracker)
            
            # Charts-Funktionen (13-17)
            elif choice == "13":
                if charts_enabled:
                    menu_show_charts(charts_manager, tracker)
                else:
                    print("‚ùå Charts-Manager nicht verf√ºgbar")
            elif choice == "14":
                if charts_enabled:
                    menu_update_charts(charts_manager)
                else:
                    print("‚ùå Charts-Manager nicht verf√ºgbar")
            elif choice == "15":
                if charts_enabled:
                    menu_charts_deals(charts_manager, tracker)
                else:
                    print("‚ùå Charts-Manager nicht verf√ºgbar")
            elif choice == "16":
                if charts_enabled:
                    menu_charts_statistics(charts_manager, tracker)
                else:
                    print("‚ùå Charts-Manager nicht verf√ºgbar")
            elif choice == "17":
                if charts_enabled:
                    menu_charts_automation(charts_manager, tracker)
                else:
                    print("‚ùå Charts-Manager nicht verf√ºgbar")
            
            # Elasticsearch-Funktionen (18-22)
            elif choice == "18":
                if es_available:
                    menu_elasticsearch_export(es_manager, tracker)
                else:
                    print("‚ùå Elasticsearch-Manager nicht verf√ºgbar")
            elif choice == "19":
                if es_available:
                    menu_elasticsearch_dashboard(es_manager)
                else:
                    print("‚ùå Elasticsearch-Manager nicht verf√ºgbar")
            elif choice == "20":
                if es_available:
                    menu_elasticsearch_analytics(es_manager)
                else:
                    print("‚ùå Elasticsearch-Manager nicht verf√ºgbar")
            elif choice == "21":
                if es_available:
                    menu_elasticsearch_config(es_manager)
                else:
                    print("‚ùå Elasticsearch-Manager nicht verf√ºgbar")
            elif choice == "22":
                if es_available:
                    menu_elasticsearch_sync(es_manager, tracker)
                else:
                    print("‚ùå Elasticsearch-Manager nicht verf√ºgbar")
            
            # System-Tools (23-27)
            elif choice == "23":
                menu_process_management()
            elif choice == "24":
                menu_batch_processing(tracker)
            elif choice == "25":
                menu_database_maintenance(tracker)
            elif choice == "26":
                menu_create_backup(tracker)
            elif choice == "27":
                menu_edit_configuration()
            
            else:
                print("‚ùå Ung√ºltige Auswahl. Bitte w√§hlen Sie eine Option zwischen 0-27.")
            
            # Pause zwischen Operationen
            if choice != "0":
                input("\nDr√ºcke Enter zum Fortfahren...")
        
        except KeyboardInterrupt:
            print("\n\n‚èπÔ∏è Programm durch Benutzer unterbrochen")
            print("üßπ Enhanced Cleanup wird ausgef√ºhrt...")
            enhanced_cleanup()
            break
        except Exception as e:
            logger.error(f"Unerwarteter Fehler in der Hauptschleife: {e}")
            print(f"‚ùå Unerwarteter Fehler: {e}")
            print("üí° Das Programm l√§uft weiter...")
            input("Dr√ºcke Enter zum Fortfahren...")

if __name__ == "__main__":
    main()